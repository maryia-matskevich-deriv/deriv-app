'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var urlUtils = require('@livechat/url-utils');
var domUtils = require('@livechat/dom-utils');
var storage = _interopDefault(require('@livechat/isomorphic-storage'));

// this is the same as "https://accounts.livechatinc.com"
// it's hardcoded here because chat.io has its own ACCOUNTS_URL
// but this variable has to have the same value for both LiveChat and chat.io
var POST_MESSAGE_ORIGIN = 'https://accounts.livechatinc.com'; // as const

var CUSTOMER_AUTH_FOOTPRINT = '@livechat/customer-auth'; // as const

var ACCOUNTS_URL = "https://accounts.livechatinc.com";

var buildParams = function buildParams(_ref, redirectUri) {
  var clientId = _ref.clientId,
      licenseId = _ref.licenseId;
  return {
    license_id: String(licenseId),
    flow: 'button',
    response_type: 'token',
    client_id: clientId,
    redirect_uri: redirectUri,
    post_message_uri: redirectUri,
    state: CUSTOMER_AUTH_FOOTPRINT
  };
};

var buildPath = function buildPath(_ref2) {
  var uniqueGroups = _ref2.uniqueGroups,
      licenseId = _ref2.licenseId,
      groupId = _ref2.groupId;
  return (uniqueGroups ? "/licence/g" + licenseId + "_" + groupId : '') + "/customer";
};

var buildSrc = function buildSrc(config, redirectUri, env) {
  var url = env === 'production' ? ACCOUNTS_URL : ACCOUNTS_URL.replace('accounts.', "accounts." + env + ".");
  var path = buildPath(config);
  var query = urlUtils.buildQueryString(buildParams(config, redirectUri));
  return "" + url + path + "?" + query;
};

var createError = function createError(_ref) {
  var code = _ref.code,
      message = _ref.message;
  var err = new Error(message);
  err.code = code;
  return err;
};

var parseTokenResponse = function parseTokenResponse(token, licenseId) {
  if ('identity_exception' in token) {
    throw createError({
      code: 'SSO_IDENTITY_EXCEPTION',
      message: token.identity_exception
    });
  }

  if ('oauth_exception' in token) {
    throw createError({
      code: 'SSO_OAUTH_EXCEPTION',
      message: token.oauth_exception
    });
  }

  return {
    accessToken: token.access_token,
    entityId: token.entity_id,
    expiresIn: token.expires_in * 1000,
    tokenType: token.token_type,
    creationDate: Date.now(),
    licenseId: licenseId
  };
};

var getPostMessageOrigin = function getPostMessageOrigin(env) {
  return env === 'production' ? POST_MESSAGE_ORIGIN : POST_MESSAGE_ORIGIN.replace('accounts.', "accounts." + env + ".");
};

var buildIframe = function buildIframe(config, env) {
  var iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.setAttribute('src', buildSrc(config, urlUtils.getOrigin(String(window.location)) + window.location.pathname, env));
  return iframe;
};

var isTokenResponse = function isTokenResponse(data) {
  return data && data.state === CUSTOMER_AUTH_FOOTPRINT;
};

var fetchToken = function fetchToken(config, env) {
  var licenseId = config.licenseId;
  var postMessageOrigin = getPostMessageOrigin(env);
  return new Promise(function (resolve, reject) {
    var iframe = buildIframe(config, env);

    var cleanup = function cleanup() {
      domUtils.removeNode(iframe); // eslint-disable-next-line no-use-before-define

      window.removeEventListener('message', listener, false);
    };

    var timeoutId = setTimeout(function () {
      cleanup();
      reject(createError({
        message: 'Request timed out.',
        code: 'REQUEST_TIMEOUT'
      }));
    }, 15 * 1000);

    var listener = function listener(_ref) {
      var origin = _ref.origin,
          data = _ref.data;

      if (origin !== postMessageOrigin) {
        return;
      }

      if (!isTokenResponse(data)) {
        return;
      }

      clearTimeout(timeoutId);
      cleanup();

      try {
        resolve(parseTokenResponse(data, licenseId));
      } catch (err) {
        reject(err);
      }
    };

    window.addEventListener('message', listener, false);
    domUtils.getRoot().then(function (body) {
      body.appendChild(iframe);
    });
  });
};

var validateConfig = function validateConfig(_ref) {
  var licenseId = _ref.licenseId,
      clientId = _ref.clientId;

  if (typeof licenseId !== 'number' || typeof clientId !== 'string') {
    throw new Error('You need to pass valid configuration object: { licenseId, clientId }.');
  }
};

var isExpiredToken = function isExpiredToken(_ref) {
  var creationDate = _ref.creationDate,
      expiresIn = _ref.expiresIn;
  return Date.now() >= creationDate + expiresIn;
};

var createAuth = function createAuth(config, env) {
  validateConfig(config);
  var cacheKey = "" + "@@lc_auth_token:" + config.licenseId + (config.uniqueGroups ? ":" + config.groupId : '');
  var pendingTokenRequest = null;
  var cachedToken = null;
  var retrievingToken = storage.getItem(cacheKey).then(function (token) {
    if (retrievingToken === null) {
      return;
    }

    retrievingToken = null;

    if (!token) {
      return;
    }

    cachedToken = JSON.parse(token);
  });

  var getFreshToken = function getFreshToken() {
    pendingTokenRequest = fetchToken(config, env).then(function (token) {
      pendingTokenRequest = null;
      storage.setItem(cacheKey, JSON.stringify(token));
      cachedToken = token;
      return token;
    }, function (err) {
      pendingTokenRequest = null;
      throw err;
    });
    return pendingTokenRequest;
  };

  var getToken = function getToken() {
    if (pendingTokenRequest) {
      return pendingTokenRequest;
    }

    if (cachedToken && !isExpiredToken(cachedToken)) {
      return Promise.resolve(cachedToken);
    }

    if (retrievingToken) {
      return retrievingToken.then(getToken);
    }

    return getFreshToken();
  };

  var hasToken = function hasToken() {
    if (retrievingToken) {
      return retrievingToken.then(hasToken);
    }

    return Promise.resolve(!!cachedToken);
  };

  var invalidate = function invalidate() {
    cachedToken = null;
    retrievingToken = null;
    return storage.removeItem(cacheKey);
  };

  return {
    getFreshToken: getFreshToken,
    getToken: getToken,
    hasToken: hasToken,
    invalidate: invalidate
  };
};

exports.default = createAuth;
exports.isExpiredToken = isExpiredToken;
exports.validateConfig = validateConfig;
