'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var urlUtils = require('@livechat/url-utils');
var storage = _interopDefault(require('@livechat/isomorphic-storage'));
var React = require('react');
var reactNativeWebview = require('react-native-webview');

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var createError = function createError(_ref) {
  var code = _ref.code,
      message = _ref.message;
  var err = new Error(message);
  err.code = code;
  return err;
};

var parseTokenResponse = function parseTokenResponse(token, licenseId) {
  if ('identity_exception' in token) {
    throw createError({
      code: 'SSO_IDENTITY_EXCEPTION',
      message: token.identity_exception
    });
  }

  if ('oauth_exception' in token) {
    throw createError({
      code: 'SSO_OAUTH_EXCEPTION',
      message: token.oauth_exception
    });
  }

  return {
    accessToken: token.access_token,
    entityId: token.entity_id,
    expiresIn: token.expires_in * 1000,
    tokenType: token.token_type,
    creationDate: Date.now(),
    licenseId: licenseId
  };
};

// this is the same as "https://accounts.livechatinc.com"

var CUSTOMER_AUTH_FOOTPRINT = '@livechat/customer-auth'; // as const

var ACCOUNTS_URL = "https://accounts.livechatinc.com";

var buildParams = function buildParams(_ref, redirectUri) {
  var clientId = _ref.clientId,
      licenseId = _ref.licenseId;
  return {
    license_id: String(licenseId),
    flow: 'button',
    response_type: 'token',
    client_id: clientId,
    redirect_uri: redirectUri,
    post_message_uri: redirectUri,
    state: CUSTOMER_AUTH_FOOTPRINT
  };
};

var buildPath = function buildPath(_ref2) {
  var uniqueGroups = _ref2.uniqueGroups,
      licenseId = _ref2.licenseId,
      groupId = _ref2.groupId;
  return (uniqueGroups ? "/licence/g" + licenseId + "_" + groupId : '') + "/customer";
};

var buildSrc = function buildSrc(config, redirectUri, env) {
  var url = env === 'production' ? ACCOUNTS_URL : ACCOUNTS_URL.replace('accounts.', "accounts." + env + ".");
  var path = buildPath(config);
  var query = urlUtils.buildQueryString(buildParams(config, redirectUri));
  return "" + url + path + "?" + query;
};

var registerRequest = null;
var injectRegisterRequest = function injectRegisterRequest(_registerRequest) {
  return registerRequest = _registerRequest;
};

var fetchToken = function fetchToken(config, env) {
  return new Promise(function (resolve, reject) {
    if (!registerRequest) {
      reject(new Error("You should render { AuthWebView } from '@livechat/customer-auth' first."));
      return;
    }

    registerRequest(buildSrc(config, config.redirectUri, env), function (token) {
      try {
        resolve(parseTokenResponse(token, config.licenseId));
      } catch (err) {
        reject(err);
      }
    });
  });
};

var validateConfig = function validateConfig(_ref) {
  var licenseId = _ref.licenseId,
      clientId = _ref.clientId,
      redirectUri = _ref.redirectUri;

  if (typeof licenseId !== 'number' || typeof clientId !== 'string' || typeof redirectUri !== 'string') {
    throw new Error('You need to pass valid configuration object: { licenseId, clientId, redirectUri }.');
  }
};

var isExpiredToken = function isExpiredToken(_ref) {
  var creationDate = _ref.creationDate,
      expiresIn = _ref.expiresIn;
  return Date.now() >= creationDate + expiresIn;
};

var createAuth = function createAuth(config, env) {
  validateConfig(config);
  var cacheKey = "" + "@@lc_auth_token:" + config.licenseId + (config.uniqueGroups ? ":" + config.groupId : '');
  var pendingTokenRequest = null;
  var cachedToken = null;
  var retrievingToken = storage.getItem(cacheKey).then(function (token) {
    if (retrievingToken === null) {
      return;
    }

    retrievingToken = null;

    if (!token) {
      return;
    }

    cachedToken = JSON.parse(token);
  });

  var getFreshToken = function getFreshToken() {
    pendingTokenRequest = fetchToken(config, env).then(function (token) {
      pendingTokenRequest = null;
      storage.setItem(cacheKey, JSON.stringify(token));
      cachedToken = token;
      return token;
    }, function (err) {
      pendingTokenRequest = null;
      throw err;
    });
    return pendingTokenRequest;
  };

  var getToken = function getToken() {
    if (pendingTokenRequest) {
      return pendingTokenRequest;
    }

    if (cachedToken && !isExpiredToken(cachedToken)) {
      return Promise.resolve(cachedToken);
    }

    if (retrievingToken) {
      return retrievingToken.then(getToken);
    }

    return getFreshToken();
  };

  var hasToken = function hasToken() {
    if (retrievingToken) {
      return retrievingToken.then(hasToken);
    }

    return Promise.resolve(!!cachedToken);
  };

  var invalidate = function invalidate() {
    cachedToken = null;
    retrievingToken = null;
    return storage.removeItem(cacheKey);
  };

  return {
    getFreshToken: getFreshToken,
    getToken: getToken,
    hasToken: hasToken,
    invalidate: invalidate
  };
};

var AuthWebView =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(AuthWebView, _React$Component);

  function AuthWebView() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.requesting = false;
    _this.requestQueue = [];
    _this.state = {
      uri: null
    };
    _this.webViewRef = null;

    _this.storeWebViewRef = function (ref) {
      return _this.webViewRef = ref;
    };

    _this.onMessage = function (event) {
      var tokenResponse = urlUtils.decodeQueryString(event.nativeEvent.data.replace(/^(\?|#)/, ''));

      var _ref = _this.requestQueue.shift(),
          callback = _ref.callback;

      callback(tokenResponse);

      if (_this.requestQueue.length === 0) {
        _this.requesting = false;
      } else {
        _this.makeRequest();
      }
    };

    return _this;
  }

  var _proto = AuthWebView.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var registerRequest = function registerRequest(uri, callback) {
      _this2.requestQueue.push({
        uri: uri,
        callback: callback
      });

      if (_this2.requesting) {
        return;
      }

      _this2.makeRequest();
    };

    injectRegisterRequest(registerRequest);
  };

  _proto.makeRequest = function makeRequest() {
    this.requesting = true;
    var uri = this.requestQueue[0].uri;

    if (this.state.uri === uri) {
      this.webViewRef.reload();
      return;
    }

    this.setState({
      uri: uri
    });
  };

  _proto.render = function render() {
    return this.state.uri ? React.createElement(reactNativeWebview.WebView, {
      injectedJavaScript: "window.ReactNativeWebView.postMessage(location.hash || location.search)",
      onMessage: this.onMessage,
      ref: this.storeWebViewRef,
      source: {
        uri: this.state.uri
      }
    }) : null;
  };

  return AuthWebView;
}(React.Component);

exports.AuthWebView = AuthWebView;
exports.default = createAuth;
exports.isExpiredToken = isExpiredToken;
exports.validateConfig = validateConfig;
