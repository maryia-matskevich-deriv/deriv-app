declare type ClearNever<T extends {}> = Pick<T, {
    [Key in keyof T]: T[Key] extends never ? never : Key;
}[keyof T]>;
declare type AnyMap = {
    [key: string]: any;
};
declare type Listener<TypesMap extends AnyMap> = <T extends keyof TypesMap>(type: T, handler: (data: TypesMap[T]) => any) => void;
declare type WildcardListener<TypesMap extends AnyMap> = (type: '*', handler: (type: keyof TypesMap, data: TypesMap[keyof TypesMap]) => any) => void;
declare type GetDefined<TypesMap extends AnyMap> = keyof ClearNever<{
    [T in keyof TypesMap]: TypesMap[T] extends undefined ? never : TypesMap[T];
}>;
declare type GetUndefined<TypesMap extends AnyMap> = keyof ClearNever<{
    [T in keyof TypesMap]: TypesMap[T] extends undefined ? TypesMap[T] : never;
}>;
declare type Emit<TypesMap extends AnyMap> = (<D extends GetDefined<TypesMap>>(type: D, data: TypesMap[D]) => void) & ((type: GetUndefined<TypesMap>) => void);
declare type OriginalMitt<TypesMap extends AnyMap> = {
    on: Listener<TypesMap> & WildcardListener<TypesMap>;
    off: Listener<TypesMap> & WildcardListener<TypesMap>;
    emit: Emit<TypesMap>;
};
export declare type Mitt<TypesMap extends AnyMap> = OriginalMitt<TypesMap> & {
    once: OriginalMitt<TypesMap>["on"];
};
declare const createMitt: <TypesMap extends AnyMap>() => {
    off: Listener<TypesMap> & WildcardListener<TypesMap> & (() => void);
    once: Listener<TypesMap> & WildcardListener<TypesMap>;
    on: Listener<TypesMap> & WildcardListener<TypesMap>;
    emit: Emit<TypesMap>;
};
export default createMitt;
//# sourceMappingURL=index.d.ts.map