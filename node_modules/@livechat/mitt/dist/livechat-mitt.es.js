import _mitt from 'mitt';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var mitt = _mitt;

// Our wrapper over `mitt` starts here
var createMitt = function createMitt() {
  var eventsMap = Object.create(null);
  var instance = mitt(eventsMap);

  var off = function off(type, handler) {
    if (!type) {
      Object.keys(eventsMap).forEach(function (key) {
        delete eventsMap[key];
      });
      return;
    }

    instance.off(type, handler);
  };

  var once = function once(type, handler) {
    // for '*' type handler is invoked with 2 arguments - type, evt
    instance.on(type, function onceHandler(data, maybeSecondArg) {
      instance.off(type, onceHandler);
      handler(data, maybeSecondArg);
    });
  };

  return _extends({}, instance, {
    off: off,
    once: once
  });
};

export default createMitt;
