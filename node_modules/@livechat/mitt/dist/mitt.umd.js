(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Mitt = factory());
}(this, (function () { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  //      
  // An event handler can take an optional event argument
  // and should not return a value
  // An array of all currently registered event handlers for a type
  // A map of event types and their corresponding event handlers.

  /** Mitt: Tiny (~200b) functional event emitter / pubsub.
   *  @name mitt
   *  @returns {Mitt}
   */
  function mitt(all) {
    all = all || Object.create(null);
    return {
      /**
       * Register an event handler for the given type.
       *
       * @param  {String} type	Type of event to listen for, or `"*"` for all events
       * @param  {Function} handler Function to call in response to given event
       * @memberOf mitt
       */
      on: function on(type, handler) {
        (all[type] || (all[type] = [])).push(handler);
      },

      /**
       * Remove an event handler for the given type.
       *
       * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
       * @param  {Function} handler Handler function to remove
       * @memberOf mitt
       */
      off: function off(type, handler) {
        if (all[type]) {
          all[type].splice(all[type].indexOf(handler) >>> 0, 1);
        }
      },

      /**
       * Invoke all handlers for the given type.
       * If present, `"*"` handlers are invoked after type-matched handlers.
       *
       * @param {String} type  The event type to invoke
       * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
       * @memberOf mitt
       */
      emit: function emit(type, evt) {
        (all[type] || []).slice().map(function (handler) {
          handler(evt);
        });
        (all['*'] || []).slice().map(function (handler) {
          handler(type, evt);
        });
      }
    };
  }

  var mitt$1 = mitt;

  // Our wrapper over `mitt` starts here
  var createMitt = function createMitt() {
    var eventsMap = Object.create(null);
    var instance = mitt$1(eventsMap);

    var off = function off(type, handler) {
      if (!type) {
        Object.keys(eventsMap).forEach(function (key) {
          delete eventsMap[key];
        });
        return;
      }

      instance.off(type, handler);
    };

    var once = function once(type, handler) {
      // for '*' type handler is invoked with 2 arguments - type, evt
      instance.on(type, function onceHandler(data, maybeSecondArg) {
        instance.off(type, onceHandler);
        handler(data, maybeSecondArg);
      });
    };

    return _extends({}, instance, {
      off: off,
      once: once
    });
  };

  return createMitt;

})));
