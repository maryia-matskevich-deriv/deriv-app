'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dataUtils = require('@livechat/data-utils');
var createDeferred = _interopDefault(require('@livechat/deferred'));
var createSockJSManager = _interopDefault(require('@livechat/sockjs-manager'));
var mitt = _interopDefault(require('@livechat/mitt'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var createConnectionHero = function createConnectionHero() {
  var resolve = dataUtils.noop;
  var timer;
  return {
    cancel: function cancel() {
      clearTimeout(timer);
      resolve = dataUtils.noop;
    },
    check: function check() {
      var deferred = createDeferred();
      resolve = deferred.resolve;
      timer = setTimeout(function () {
        var err = new Error('Timeout.');
        err.code = 'TIMEOUT';
        deferred.reject(err);
      }, 2000);
      return deferred.promise;
    },
    resolve: function (_resolve) {
      function resolve() {
        return _resolve.apply(this, arguments);
      }

      resolve.toString = function () {
        return _resolve.toString();
      };

      return resolve;
    }(function () {
      clearTimeout(timer);
      resolve();
    })
  };
};

// based on server heartbeat interval - which is 25s
var DEFAULT_RESCHEDULE_PING_TIMEOUT = 30 * 1000;

// this is not quite type-safe (it doesn't constraint soure & sink types that much)
// it's generic and really simple though, so we don't waste time to make this completely type-safe
var forwardEvents = function forwardEvents(source, sink, types) {
  types.forEach(function (type) {
    source.on(type, function (data) {
      sink.emit(type, data);
    });
  });
};

var createPlatformClient = function createPlatformClient(url, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$query = _ref.query,
      query = _ref$query === void 0 ? {} : _ref$query,
      _ref$rescheduleTimeou = _ref.rescheduleTimeout,
      rescheduleTimeout = _ref$rescheduleTimeou === void 0 ? DEFAULT_RESCHEDULE_PING_TIMEOUT : _ref$rescheduleTimeou,
      transports = _ref.transports,
      _ref$emitter = _ref.emitter,
      emitter = _ref$emitter === void 0 ? mitt() : _ref$emitter;

  var manager = createSockJSManager(url, {
    query: _extends({
      // needed for HAProxy sticky sessions
      bh: dataUtils.generateRandomId()
    }, query),
    transports: transports
  });
  var pingTimer;
  var connectionHero = createConnectionHero();

  var isSocketOpen = function isSocketOpen() {
    return manager.getReadyState() === 1;
  };

  var emit = function emit(frame) {
    manager.emit(JSON.stringify(frame));
    reschedulePing();
  };

  var ping = function ping() {
    // ping action doesn't extend Outgoing - it's internal, so doesn't have to be specified by a consumer
    // but it's safe to use emit with it
    emit({
      action: 'ping'
    });
  }; // extra measure to keep the connection alive
  // in theory this timer should never fire though
  // because we ping after each received heartbeat & sent request


  var reschedulePing = function reschedulePing() {
    clearTimeout(pingTimer);
    pingTimer = setTimeout(ping, rescheduleTimeout);
  };

  var cleanupPossiblyPendingTasks = function cleanupPossiblyPendingTasks() {
    connectionHero.cancel();
    clearTimeout(pingTimer);
  };

  forwardEvents(manager, emitter, ['connect', 'disconnect']);
  manager.on('connect', reschedulePing);
  manager.on('disconnect', cleanupPossiblyPendingTasks); // ping has to be sent back upon receiving heartbeat
  // this is somewhat guaranteed to be executed asap unlike browser timers

  manager.on('heartbeat', ping);
  manager.on('message', function (data) {
    connectionHero.resolve();
    var message = JSON.parse(data);

    if (message.action === 'ping') {
      return;
    } // Incoming requires `action` property to be a string, we cannot forbid in typings `ping` as valid action though
    // so TS cannot narrow the type down to `Incoming` here (it stays `Incoming | Ping`), that's why we are using `any` here


    emitter.emit('message', message);
  }); // React Native uses window as global object, but without addEventListener method

  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {
    window.addEventListener('online', function () {
      if (!isSocketOpen()) {
        return;
      }

      connectionHero.check().then(function () {
        connectionHero.cancel();
        emitter.emit('connection_recovered');
      }, function (err) {
        connectionHero.cancel();

        if (err.code !== 'TIMEOUT') {
          throw err;
        }

        manager.reconnect();
      });
      ping();
    });
    window.addEventListener('offline', function () {
      connectionHero.cancel();

      if (!isSocketOpen()) {
        return;
      }

      emitter.emit('connection_unstable');
    });
  }

  return _extends({}, manager, {
    destroy: function destroy() {
      cleanupPossiblyPendingTasks();
      manager.destroy();
    },
    disconnect: function disconnect() {
      cleanupPossiblyPendingTasks();
      manager.disconnect();
    },
    reconnect: function reconnect(delay) {
      cleanupPossiblyPendingTasks();
      manager.reconnect(delay);
    },
    emit: emit,
    on: emitter.on,
    off: emitter.off
  });
};

exports.default = createPlatformClient;
