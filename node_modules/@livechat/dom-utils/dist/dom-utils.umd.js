(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Differ = {}));
}(this, (function (exports) { 'use strict';

  function add(first, second) {
    return first + second;
  }

  var _ref = {},
      hasOwnProperty = _ref.hasOwnProperty;

  function hasOwn(prop, obj) {
    return hasOwnProperty.call(obj, prop);
  }

  function findIndex(predicate, arr) {
    for (var index = 0; index < arr.length; index++) {
      if (predicate(arr[index])) {
        return index;
      }
    }

    return -1;
  }

  function forOwn(callback, obj) {
    return Object.keys(obj).forEach(function (key) {
      callback(obj[key], key);
    });
  }

  function pick(props, obj) {
    return props.reduce(function (acc, prop) {
      acc[prop] = obj[prop];
      return acc;
    }, {});
  }

  function sum(numbers) {
    return numbers.reduce(add, 0);
  }

  var applyStyle = (function (style, element) {
    forOwn(function (value, key) {
      element.style[key] = value;
    }, style);
  });

  var applyElementSpec = (function (attributes, element) {
    var iteratee = function iteratee(value, key) {
      if (key === 'style') {
        applyStyle(value, element);
        return;
      }

      element.setAttribute(key, value);
    };

    forOwn(iteratee, attributes);
  });

  var isIE = function isIE() {
    return !!document.documentElement.currentStyle;
  };

  var getComputedStyle$1 = function getComputedStyle(props, element) {
    var styles = window.getComputedStyle(element);
    var borderBox = styles.boxSizing === 'border-box';
    var picked = pick(props, styles);

    if (isIE() && borderBox && hasOwn('width', picked) && picked.width !== null) {
      var widths = [picked.width, styles.paddingLeft, styles.paddingRight, styles.borderLeftWidth, styles.borderRightWidth];
      picked.width = sum(widths.map(parseFloat)) + 'px';
    }

    if (isIE() && borderBox && hasOwn('height', picked) && picked.height !== null) {
      var heights = [picked.height, styles.paddingTop, styles.paddingBottom, styles.borderTopWidth, styles.borderBottomWidth];
      picked.height = sum(heights.map(parseFloat)) + 'px';
    }

    return picked;
  };

  /*!
  * tabbable 5.1.4
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  */
  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
  var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
  var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  var getCandidates = function getCandidates(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));

    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }

    candidates = candidates.filter(filter);
    return candidates;
  };

  var isContentEditable = function isContentEditable(node) {
    return node.contentEditable === 'true';
  };

  var getTabindex = function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

    if (!isNaN(tabindexAttr)) {
      return tabindexAttr;
    } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.


    if (isContentEditable(node)) {
      return 0;
    } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    //  yet they are still part of the regular tab order; in FF, they get a default
    //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    //  order, consider their tab index to be 0.


    if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
      return 0;
    }

    return node.tabIndex;
  };

  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  };

  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };

  var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  };

  var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
      return child.tagName === 'SUMMARY';
    });
    return r;
  };

  var getCheckedRadio = function getCheckedRadio(nodes, form) {
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].checked && nodes[i].form === form) {
        return nodes[i];
      }
    }
  };

  var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) {
      return true;
    }

    var radioScope = node.form || node.ownerDocument;
    var radioSet = radioScope.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };

  var isRadio = function isRadio(node) {
    return isInput(node) && node.type === 'radio';
  };

  var isNonTabbableRadio = function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };

  var isHidden = function isHidden(node) {
    if (getComputedStyle(node).visibility === 'hidden') {
      return true;
    }

    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
      return true;
    }

    while (node) {
      if (getComputedStyle(node).display === 'none') {
        return true;
      }

      node = node.parentElement;
    }

    return false;
  };

  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node) ||
    /* For a details element with a summary, the summary element gets the focused  */
    isDetailsWithSummary(node)) {
      return false;
    }

    return true;
  };

  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(node) {
    if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
      return false;
    }

    return true;
  };

  var tabbable = function tabbable(el, options) {
    options = options || {};
    var regularTabbables = [];
    var orderedTabbables = [];
    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable);
    candidates.forEach(function (candidate, i) {
      var candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    });
    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
      return a.node;
    }).concat(regularTabbables);
    return tabbableNodes;
  };

  var focusable = function focusable(el, options) {
    options = options || {};
    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable);
    return candidates;
  };

  var isTabbable = function isTabbable(node) {
    if (!node) {
      throw new Error('No node provided');
    }

    if (matches.call(node, candidateSelector) === false) {
      return false;
    }

    return isNodeMatchingSelectorTabbable(node);
  };

  var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

  var isFocusable = function isFocusable(node) {
    if (!node) {
      throw new Error('No node provided');
    }

    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }

    return isNodeMatchingSelectorFocusable(node);
  };

  function getNextTabbable(element, container) {
    if (container === void 0) {
      container = document.body;
    }

    var tabbables = tabbable(container);
    var elementIndex = findIndex(function (el) {
      return el === element;
    }, tabbables);
    var isElementLast = elementIndex === tabbables.length - 1;
    return tabbables[isElementLast ? 0 : elementIndex + 1];
  }

  function getRoot() {
    return new Promise(function (resolve) {
      var next = function next() {
        if (!document.body) {
          setTimeout(next, 100);
          return;
        }

        resolve(document.body);
      };

      next();
    });
  }

  function getScrollOffset(source, target) {
    var sourceRect = source.getBoundingClientRect();
    var targetRect = target.getBoundingClientRect();
    return {
      top: sourceRect.top + target.scrollTop - targetRect.top,
      left: sourceRect.left + target.scrollLeft - targetRect.left
    };
  }

  var cachedRTLOffsetType = null; // https://github.com/bvaughn/react-window/blob/c035eee067ea89029c89ecffd9eade1fc2ecb2dd/src/domHelpers.js#L31-L36

  var getRTLOffsetType = function getRTLOffsetType() {
    if (cachedRTLOffsetType) {
      return cachedRTLOffsetType;
    }

    var outerDiv = document.createElement('div');
    var outerStyle = outerDiv.style;
    outerStyle.width = '50px';
    outerStyle.height = '50px';
    outerStyle.overflow = 'scroll';
    outerStyle.direction = 'rtl';
    var innerDiv = document.createElement('div');
    var innerStyle = innerDiv.style;
    innerStyle.width = '100px';
    innerStyle.height = '50px';
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);

    if (outerDiv.scrollLeft > 0) {
      // Chrome 😩
      // it renders initially with max scrollLeft and to shift it to the left we need to subtract the distance
      cachedRTLOffsetType = 'positive-descending';
    } else {
      outerDiv.scrollLeft = 1;

      if (outerDiv.scrollLeft === 0) {
        // spec-compliant
        // it renders initially with 0 and to shift it to the left we need to subtract the distance
        cachedRTLOffsetType = 'negative';
      } else {
        // non-chromium Edge 🤦‍♂️
        // it renders initially with 0 and to shift it to the left we need to add the distance
        cachedRTLOffsetType = 'positive-ascending';
      }
    }

    document.body.removeChild(outerDiv);
    return cachedRTLOffsetType;
  };

  function isScrollOnBottom(node, threshold) {
    if (threshold === void 0) {
      threshold = 0;
    }

    return Math.abs(node.scrollTop + node.clientHeight - node.scrollHeight) <= threshold;
  }

  function isScrollOnTop(node, threshold) {
    if (threshold === void 0) {
      threshold = 0;
    }

    return node.scrollTop <= threshold;
  }

  function prependChild(parentElement, newElement) {
    parentElement.insertBefore(newElement, parentElement.children[0]);
  }

  function scrollToBottom(node) {
    node.scrollTop = node.scrollHeight;
  }

  function scrollToTop(node) {
    node.scrollTop = 0;
  }

  function removeNode(node) {
    var parentNode = node.parentNode;

    if (parentNode) {
      parentNode.removeChild(node);
    }
  }

  var createElement = function createElement(tagName, spec) {
    var element = document.createElement(tagName);
    applyElementSpec(spec, element);
    return element;
  };

  exports.applyElementSpec = applyElementSpec;
  exports.applyStyle = applyStyle;
  exports.createElement = createElement;
  exports.focusable = focusable;
  exports.getComputedStyle = getComputedStyle$1;
  exports.getNextTabbable = getNextTabbable;
  exports.getRTLOffsetType = getRTLOffsetType;
  exports.getRoot = getRoot;
  exports.getScrollOffset = getScrollOffset;
  exports.isFocusable = isFocusable;
  exports.isScrollOnBottom = isScrollOnBottom;
  exports.isScrollOnTop = isScrollOnTop;
  exports.isTabbable = isTabbable;
  exports.prependChild = prependChild;
  exports.removeNode = removeNode;
  exports.scrollToBottom = scrollToBottom;
  exports.scrollToTop = scrollToTop;
  exports.tabbable = tabbable;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
