'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dataUtils = require('@livechat/data-utils');
var tabbable = require('tabbable');

var applyStyle = (function (style, element) {
  dataUtils.forOwn(function (value, key) {
    element.style[key] = value;
  }, style);
});

var applyElementSpec = (function (attributes, element) {
  var iteratee = function iteratee(value, key) {
    if (key === 'style') {
      applyStyle(value, element);
      return;
    }

    element.setAttribute(key, value);
  };

  dataUtils.forOwn(iteratee, attributes);
});

var isIE = function isIE() {
  return !!document.documentElement.currentStyle;
};

var getComputedStyle = function getComputedStyle(props, element) {
  var styles = window.getComputedStyle(element);
  var borderBox = styles.boxSizing === 'border-box';
  var picked = dataUtils.pick(props, styles);

  if (isIE() && borderBox && dataUtils.hasOwn('width', picked) && picked.width !== null) {
    var widths = [picked.width, styles.paddingLeft, styles.paddingRight, styles.borderLeftWidth, styles.borderRightWidth];
    picked.width = dataUtils.sum(widths.map(parseFloat)) + 'px';
  }

  if (isIE() && borderBox && dataUtils.hasOwn('height', picked) && picked.height !== null) {
    var heights = [picked.height, styles.paddingTop, styles.paddingBottom, styles.borderTopWidth, styles.borderBottomWidth];
    picked.height = dataUtils.sum(heights.map(parseFloat)) + 'px';
  }

  return picked;
};

function getNextTabbable(element, container) {
  if (container === void 0) {
    container = document.body;
  }

  var tabbables = tabbable.tabbable(container);
  var elementIndex = dataUtils.findIndex(function (el) {
    return el === element;
  }, tabbables);
  var isElementLast = elementIndex === tabbables.length - 1;
  return tabbables[isElementLast ? 0 : elementIndex + 1];
}

function getRoot() {
  return new Promise(function (resolve) {
    var next = function next() {
      if (!document.body) {
        setTimeout(next, 100);
        return;
      }

      resolve(document.body);
    };

    next();
  });
}

function getScrollOffset(source, target) {
  var sourceRect = source.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  return {
    top: sourceRect.top + target.scrollTop - targetRect.top,
    left: sourceRect.left + target.scrollLeft - targetRect.left
  };
}

var cachedRTLOffsetType = null; // https://github.com/bvaughn/react-window/blob/c035eee067ea89029c89ecffd9eade1fc2ecb2dd/src/domHelpers.js#L31-L36

var getRTLOffsetType = function getRTLOffsetType() {
  if (cachedRTLOffsetType) {
    return cachedRTLOffsetType;
  }

  var outerDiv = document.createElement('div');
  var outerStyle = outerDiv.style;
  outerStyle.width = '50px';
  outerStyle.height = '50px';
  outerStyle.overflow = 'scroll';
  outerStyle.direction = 'rtl';
  var innerDiv = document.createElement('div');
  var innerStyle = innerDiv.style;
  innerStyle.width = '100px';
  innerStyle.height = '50px';
  outerDiv.appendChild(innerDiv);
  document.body.appendChild(outerDiv);

  if (outerDiv.scrollLeft > 0) {
    // Chrome üò©
    // it renders initially with max scrollLeft and to shift it to the left we need to subtract the distance
    cachedRTLOffsetType = 'positive-descending';
  } else {
    outerDiv.scrollLeft = 1;

    if (outerDiv.scrollLeft === 0) {
      // spec-compliant
      // it renders initially with 0 and to shift it to the left we need to subtract the distance
      cachedRTLOffsetType = 'negative';
    } else {
      // non-chromium Edge ü§¶‚Äç‚ôÇÔ∏è
      // it renders initially with 0 and to shift it to the left we need to add the distance
      cachedRTLOffsetType = 'positive-ascending';
    }
  }

  document.body.removeChild(outerDiv);
  return cachedRTLOffsetType;
};

function isScrollOnBottom(node, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  return Math.abs(node.scrollTop + node.clientHeight - node.scrollHeight) <= threshold;
}

function isScrollOnTop(node, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  return node.scrollTop <= threshold;
}

function prependChild(parentElement, newElement) {
  parentElement.insertBefore(newElement, parentElement.children[0]);
}

function scrollToBottom(node) {
  node.scrollTop = node.scrollHeight;
}

function scrollToTop(node) {
  node.scrollTop = 0;
}

function removeNode(node) {
  var parentNode = node.parentNode;

  if (parentNode) {
    parentNode.removeChild(node);
  }
}

var createElement = function createElement(tagName, spec) {
  var element = document.createElement(tagName);
  applyElementSpec(spec, element);
  return element;
};

Object.keys(tabbable).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return tabbable[k];
		}
	});
});
exports.applyElementSpec = applyElementSpec;
exports.applyStyle = applyStyle;
exports.createElement = createElement;
exports.getComputedStyle = getComputedStyle;
exports.getNextTabbable = getNextTabbable;
exports.getRTLOffsetType = getRTLOffsetType;
exports.getRoot = getRoot;
exports.getScrollOffset = getScrollOffset;
exports.isScrollOnBottom = isScrollOnBottom;
exports.isScrollOnTop = isScrollOnTop;
exports.prependChild = prependChild;
exports.removeNode = removeNode;
exports.scrollToBottom = scrollToBottom;
exports.scrollToTop = scrollToTop;
