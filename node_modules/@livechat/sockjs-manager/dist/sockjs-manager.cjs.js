'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var SockJS = _interopDefault(require('sockjs-client'));
var mitt = _interopDefault(require('@livechat/mitt'));
var urlUtils = require('@livechat/url-utils');

var backo = function backo(_ref) {
  var _ref$min = _ref.min,
      min = _ref$min === void 0 ? 1000 : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? 5000 : _ref$max,
      _ref$jitter = _ref.jitter,
      jitter = _ref$jitter === void 0 ? 0.5 : _ref$jitter;
  var attempts = 0;
  return {
    duration: function duration() {
      var ms = min * Math.pow(2, attempts++);

      if (jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }

      return Math.min(ms, max) | 0;
    },
    reset: function reset() {
      attempts = 0;
    }
  };
};

// based on WebSocket's readyState - https://www.w3.org/TR/websockets/#the-websocket-interface
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 3;

var createSockJSManager = function createSockJSManager(url, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      query = _ref.query,
      _ref$transports = _ref.transports,
      transports = _ref$transports === void 0 ? ['websocket', 'xhr-polling'] : _ref$transports;

  var finalUrl = "" + url + (!query ? '' : '?' + urlUtils.buildQueryString(query));
  var emitter = mitt();
  var backoff = backo({
    min: 1000,
    max: 5000,
    jitter: 0.5
  });
  var state = CLOSED;
  var reconnectTimer;
  var socket = null;

  var openListener = function openListener() {
    state = OPEN;
    backoff.reset();
    emitter.emit('connect');
  };

  var closeListener = function closeListener() {
    state = CLOSED;
    socket = null;
    emitter.emit('disconnect'); // eslint-disable-next-line no-use-before-define

    reconnect();
  };

  var messageListener = function messageListener(_ref2) {
    var data = _ref2.data;
    emitter.emit("message", data);
  };

  var heartbeatListener = function heartbeatListener() {
    emitter.emit('heartbeat');
  };

  var addEventListeners = function addEventListeners(instance) {
    instance.addEventListener('open', openListener);
    instance.addEventListener('close', closeListener);
    instance.addEventListener('message', messageListener);
    instance.addEventListener('heartbeat', heartbeatListener);
  };

  var removeEventListeners = function removeEventListeners(instance) {
    instance.removeEventListener('open', openListener);
    instance.removeEventListener('close', closeListener);
    instance.removeEventListener('message', messageListener);
    instance.removeEventListener('heartbeat', heartbeatListener);
  };

  var close = function close() {
    state = CLOSED;

    if (!socket) {
      return;
    }

    removeEventListeners(socket);
    socket.close();
    socket = null;
  };

  var connect = function connect() {
    state = CONNECTING;
    socket = new SockJS(finalUrl, undefined, {
      transports: transports
    });
    addEventListeners(socket);
  };

  var reconnect = function reconnect(delay) {
    if (delay === void 0) {
      delay = backoff.duration();
    }

    clearTimeout(reconnectTimer);

    if (delay === 0) {
      connect();
      return;
    }

    reconnectTimer = setTimeout(connect, delay);
  };

  var managedSocket = {
    connect: function (_connect) {
      function connect() {
        return _connect.apply(this, arguments);
      }

      connect.toString = function () {
        return _connect.toString();
      };

      return connect;
    }(function () {
      if (state !== CLOSED) {
        throw new Error('Socket is already open or connecting.');
      }

      clearTimeout(reconnectTimer);
      connect();
    }),
    destroy: function destroy() {
      managedSocket.off();
      managedSocket.disconnect();
    },
    disconnect: function disconnect() {
      state = CLOSED;
      clearTimeout(reconnectTimer);
      close();
    },
    reconnect: function (_reconnect) {
      function reconnect(_x) {
        return _reconnect.apply(this, arguments);
      }

      reconnect.toString = function () {
        return _reconnect.toString();
      };

      return reconnect;
    }(function (delay) {
      close();
      reconnect(delay);
    }),
    emit: function emit(data) {
      if (state !== OPEN) {
        throw new Error('Socket is not connected.');
      } // if we are connected we can be sure that socket is defined


      socket.send(data);
    },
    getReadyState: function getReadyState() {
      return state;
    },
    on: emitter.on,
    off: emitter.off
  };
  return managedSocket;
};

exports.default = createSockJSManager;
