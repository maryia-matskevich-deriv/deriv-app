import { mapValues, noop, hasOwn, identity, isObject, pickOwn, toPairs, generateUniqueId, pick, keyBy, isEmpty, flatMap, includes, last, numericSortBy, stringCompare, uniqBy } from '@livechat/data-utils';
import deferred from '@livechat/deferred';
import { createStore, applyMiddleware } from 'redux';
import createSideEffectsMiddleware from '@livechat/side-effects-middleware';
import storage from '@livechat/isomorphic-storage';
import promiseTry from '@livechat/promise-try';
import Backo from 'backo2';
import unfetch from 'unfetch';
import { buildQueryString } from '@livechat/url-utils';
import createPlatformClient from '@livechat/platform-client';
import mitt from '@livechat/mitt';
import rawUploadFile from '@livechat/file-upload';
import createAuth, { validateConfig } from '@livechat/customer-auth';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");

  return typeof key === "symbol" ? key : String(key);
}

var CHANGE_REGION = 'change_region';
var CHECK_GOALS = 'check_goals';
var DESTROY = 'destroy';
var FAIL_ALL_REQUESTS = 'fail_all_requests';
var LOGIN_SUCCESS = 'login_success';
var PAUSE_CONNECTION = 'pause_connection';
var PREFETCH_TOKEN = 'prefetch_token';
var PUSH_RECEIVED = 'push_received';
var PUSH_RESPONSE_RECEIVED = 'push_response_received';
var RECONNECT = 'reconnect';
var REQUEST_FAILED = 'request_failed';
var RESPONSE_RECEIVED = 'response_received';
var SEND_REQUEST = 'send_request';
var SET_CHAT_ACTIVE = 'set_chat_active';
var SET_SELF_ID = 'set_self_id';
var SOCKET_CONNECTED = 'socket_connected';
var SOCKET_DISCONNECTED = 'socket_disconnected';
var SOCKET_RECOVERED = 'socket_recovered';
var SOCKET_UNSTABLE = 'socket_unstable';
var START_CONNECTION = 'start_connection';
var UPDATE_CUSTOMER_PAGE = 'update_customer_page';

var CONNECTION_LOST = 'CONNECTION_LOST';
var IDENTITY_MISMATCH = 'IDENTITY_MISMATCH';
var MISDIRECTED_CONNECTION = 'MISDIRECTED_CONNECTION';
var MISSING_CHAT_THREAD = 'MISSING_CHAT_THREAD';
var REQUEST_TIMEOUT = 'REQUEST_TIMEOUT';
var TOO_MANY_UNAUTHORIZED_CONNECTIONS = 'TOO_MANY_UNAUTHORIZED_CONNECTIONS';

var ACCEPT_GREETING = 'accept_greeting';
var ACTIVATE_CHAT = 'activate_chat';
var CANCEL_GREETING = 'cancel_greeting';
var CHECK_GOALS$1 = 'check_goals';
var DEACTIVATE_CHAT = 'deactivate_chat';
var DELETE_CHAT_PROPERTIES = 'delete_chat_properties';
var DELETE_EVENT_PROPERTIES = 'delete_event_properties';
var DELETE_THREAD_PROPERTIES = 'delete_thread_properties';
var GET_CHAT = 'get_chat';
var GET_CUSTOMER = 'get_customer';
var GET_FORM = 'get_form';
var GET_PREDICTED_AGENT = 'get_predicted_agent';
var GET_URL_INFO = 'get_url_info';
var LIST_CHATS = 'list_chats';
var LIST_GROUP_STATUSES = 'list_group_statuses';
var LIST_THREADS = 'list_threads';
var LOGIN = 'login';
var MARK_EVENTS_AS_SEEN = 'mark_events_as_seen';
var SEND_EVENT = 'send_event';
var SEND_RICH_MESSAGE_POSTBACK = 'send_rich_message_postback';
var SEND_SNEAK_PEEK = 'send_sneak_peek';
var SET_CUSTOMER_SESSION_FIELDS = 'set_customer_session_fields';
var START_CHAT = 'start_chat';
var UPDATE_CHAT_PROPERTIES = 'update_chat_properties';
var UPDATE_CUSTOMER = 'update_customer';
var UPDATE_CUSTOMER_PAGE$1 = 'update_customer_page';
var UPDATE_EVENT_PROPERTIES = 'update_event_properties';
var UPDATE_THREAD_PROPERTIES = 'update_thread_properties';
var UPLOAD_FILE = 'upload_file';

var DESC = 'desc';

var createReducer = function createReducer(initialState, reducersMap) {
  if (process.env.NODE_ENV !== 'development' && reducersMap[undefined]) {
    // eslint-disable-next-line no-console
    console.warn(["Reducer contains an 'undefined' action type.", 'Have you misspelled a constant?'].join('\n'));
  }

  return function reducer(state, action) {
    if (state === void 0) {
      state = initialState;
    }

    if (hasOwn(action.type, reducersMap)) {
      return reducersMap[action.type](state, action.payload);
    }

    return state;
  };
}; // TODO: this is the same as built-in redux's combineReducers, should be remobed

var CONNECTED = 'connected';
var DESTROYED = 'destroyed';
var DISCONNECTED = 'disconnected';
var PAUSED = 'paused';
var RECONNECTING = 'reconnecting';

var AGENT = 'agent';
var CUSTOMER = 'customer';

var getAllRequests = function getAllRequests(state) {
  return state.requests;
};
var getConnectionStatus = function getConnectionStatus(state) {
  return state.connection.status;
};
var getRequest = function getRequest(state, id) {
  return state.requests[id];
};
var getSelfId = function getSelfId(state) {
  return state.users.self.id;
};
var isChatActive = function isChatActive(state, chatId) {
  var chat = state.chats[chatId];
  return !!chat && chat.active;
};
var isConnected = function isConnected(state) {
  return getConnectionStatus(state) === CONNECTED;
};
var isDestroyed = function isDestroyed(state) {
  return getConnectionStatus(state) === DESTROYED;
};

var getEnvPart = function getEnvPart(_ref) {
  var licenseId = _ref.licenseId,
      env = _ref.env;

  if (licenseId === 1520) {
    return '.staging';
  }

  if (env === 'production') {
    return '';
  }

  return "." + env;
};

var getApiOrigin = function getApiOrigin(state) {
  var region = state.region;
  var regionPart = region ? "-" + region : '';
  return "https://api" + regionPart + getEnvPart(state) + ".livechatinc.com";
};
var getServerUrl = function getServerUrl(state) {
  return getApiOrigin(state) + "/v3.2/customer";
};
var createInitialState = function createInitialState(initialStateData) {
  var _initialStateData$app = initialStateData.application,
      application = _initialStateData$app === void 0 ? {} : _initialStateData$app,
      licenseId = initialStateData.licenseId,
      _initialStateData$gro = initialStateData.groupId,
      groupId = _initialStateData$gro === void 0 ? null : _initialStateData$gro,
      env = initialStateData.env,
      _initialStateData$pag = initialStateData.page,
      page = _initialStateData$pag === void 0 ? null : _initialStateData$pag,
      _initialStateData$reg = initialStateData.region,
      region = _initialStateData$reg === void 0 ? null : _initialStateData$reg,
      _initialStateData$ref = initialStateData.referrer,
      referrer = _initialStateData$ref === void 0 ? null : _initialStateData$ref,
      _initialStateData$uni = initialStateData.uniqueGroups,
      uniqueGroups = _initialStateData$uni === void 0 ? false : _initialStateData$uni,
      _initialStateData$mob = initialStateData.mobile,
      mobile = _initialStateData$mob === void 0 ? false : _initialStateData$mob;
  return {
    application: _extends({}, application, {
      name: "customer_sdk",
      version: "2.0.4"
    }),
    licenseId: licenseId,
    env: env,
    groupId: groupId,
    chats: {},
    connection: {
      status: DISCONNECTED
    },
    page: page,
    region: region,
    referrer: referrer,
    requests: {},
    users: {
      self: {
        id: null,
        type: CUSTOMER
      },
      others: {}
    },
    uniqueGroups: uniqueGroups,
    mobile: mobile
  };
};

var removeStoredRequest = function removeStoredRequest(state, _ref2) {
  var id = _ref2.id;

  // eslint-disable-next-line no-unused-vars
  var _state$requests = state.requests,
      requests = _objectWithoutPropertiesLoose(_state$requests, [id].map(_toPropertyKey));

  return _extends({}, state, {
    requests: requests
  });
};

var setConnectionStatus = function setConnectionStatus(status, state) {
  return _extends({}, state, {
    connection: _extends({}, state.connection, {
      status: status
    })
  });
};

var createReducer$1 = (function (state) {
  var _createReducer;

  return createReducer(state, (_createReducer = {}, _createReducer[CHANGE_REGION] = function (state, _ref3) {
    var region = _ref3.region;
    return _extends({}, state, {
      region: region
    });
  }, _createReducer[DESTROY] = function (state) {
    return setConnectionStatus(DESTROYED, state);
  }, _createReducer[LOGIN_SUCCESS] = function (state) {
    return setConnectionStatus(CONNECTED, state);
  }, _createReducer[PAUSE_CONNECTION] = function (state) {
    return setConnectionStatus(PAUSED, state);
  }, _createReducer[REQUEST_FAILED] = removeStoredRequest, _createReducer[RESPONSE_RECEIVED] = removeStoredRequest, _createReducer[SEND_REQUEST] = function (state, _ref4) {
    var _extends2;

    var promise = _ref4.promise,
        resolve = _ref4.resolve,
        reject = _ref4.reject,
        id = _ref4.id,
        request = _ref4.request;
    return _extends({}, state, {
      requests: _extends({}, state.requests, (_extends2 = {}, _extends2[id] = {
        id: id,
        promise: promise,
        resolve: resolve,
        reject: reject,
        request: request
      }, _extends2))
    });
  }, _createReducer[SET_CHAT_ACTIVE] = function (state, _ref5) {
    var _extends3;

    var id = _ref5.id,
        active = _ref5.active;
    return _extends({}, state, {
      chats: _extends({}, state.chats, (_extends3 = {}, _extends3[id] = _extends({}, state.chats[id], {
        active: active
      }), _extends3))
    });
  }, _createReducer[SET_SELF_ID] = function (state, payload) {
    return _extends({}, state, {
      users: _extends({}, state.users, {
        self: _extends({}, state.users.self, {
          id: payload.id
        })
      })
    });
  }, _createReducer[SOCKET_DISCONNECTED] = function (state) {
    var previousStatus = getConnectionStatus(state);

    if (process.env.NODE_ENV !== 'production' && (previousStatus === PAUSED || previousStatus === DESTROYED)) {
      throw new Error("Got 'socket_disconnected' action when in " + previousStatus + " state. This should be an impossible state.");
    }

    var state1 = setConnectionStatus(previousStatus === DISCONNECTED ? DISCONNECTED : RECONNECTING, state);
    return _extends({}, state1, {
      requests: {}
    });
  }, _createReducer[UPDATE_CUSTOMER_PAGE] = function (state, page) {
    return _extends({}, state, {
      page: _extends({}, state.page, page)
    });
  }, _createReducer));
});

function finalCreateStore(initialStateData) {
  var compose = process.env.NODE_ENV === 'development' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    name: '@livechat/customer-sdk'
  }) : identity;
  var sideEffectsMiddleware = createSideEffectsMiddleware();
  var store = createStore(createReducer$1(createInitialState(initialStateData)), compose(applyMiddleware(sideEffectsMiddleware)));
  store.addSideEffectsHandler = sideEffectsMiddleware.add;
  return store;
}

function createError(_ref) {
  var message = _ref.message,
      code = _ref.code;
  var error = new Error(message);
  error.code = code;
  return error;
}

var ACCESS_TOKEN_EXPIRED = 'access_token_expired';
var CUSTOMER_BANNED = 'customer_banned';
var CUSTOMER_TEMPORARILY_BLOCKED = 'customer_temporarily_blocked';
var LICENSE_NOT_FOUND = 'license_not_found';
var MISDIRECTED_CONNECTION$1 = 'misdirected_connection';
var PRODUCT_VERSION_CHANGED = 'product_version_changed';
var TOO_MANY_CONNECTIONS = 'too_many_connections'; // the limit of unauthorized connections is per IP

var TOO_MANY_UNAUTHORIZED_CONNECTIONS$1 = 'too_many_unauthorized_connections';
var UNSUPPORTED_VERSION = 'unsupported_version';

var CHAT_DEACTIVATED = 'chat_deactivated';
var CHAT_PROPERTIES_DELETED = 'chat_properties_deleted';
var CHAT_PROPERTIES_UPDATED = 'chat_properties_updated';
var CHAT_TRANSFERRED = 'chat_transferred';
var CUSTOMER_DISCONNECTED = 'customer_disconnected';
var CUSTOMER_PAGE_UPDATED = 'customer_page_updated';
var CUSTOMER_SIDE_STORAGE_UPDATED = 'customer_side_storage_updated';
var CUSTOMER_UPDATED = 'customer_updated';
var EVENT_PROPERTIES_DELETED = 'event_properties_deleted';
var EVENT_PROPERTIES_UPDATED = 'event_properties_updated';
var EVENT_UPDATED = 'event_updated';
var EVENTS_MARKED_AS_SEEN = 'events_marked_as_seen';
var GREETING_ACCEPTED = 'greeting_accepted';
var GREETING_CANCELED = 'greeting_canceled';
var INCOMING_CHAT = 'incoming_chat';
var INCOMING_EVENT = 'incoming_event';
var INCOMING_GREETING = 'incoming_greeting';
var INCOMING_MULTICAST = 'incoming_multicast';
var INCOMING_RICH_MESSAGE_POSTBACK = 'incoming_rich_message_postback';
var INCOMING_TYPING_INDICATOR = 'incoming_typing_indicator';
var QUEUE_POSITION_UPDATED = 'queue_position_updated';
var THREAD_PROPERTIES_DELETED = 'thread_properties_deleted';
var THREAD_PROPERTIES_UPDATED = 'thread_properties_updated';
var USER_ADDED_TO_CHAT = 'user_added_to_chat';
var USER_REMOVED_FROM_CHAT = 'user_removed_from_chat';

var FILE = 'file';
var FILLED_FORM = 'filled_form';
var MESSAGE = 'message';
var RICH_MESSAGE = 'rich_message';
var SYSTEM_MESSAGE = 'system_message';

var createEventBase = function createEventBase(event) {
  var base = {};

  if (typeof event.customId === 'string') {
    base.custom_id = event.customId;
  }

  if (isObject(event.properties)) {
    base.properties = event.properties;
  }

  return base;
}; // TODO: we could validate and throw here
// but should we? maybe only in DEV mode?


var parseEvent = function parseEvent(event) {
  switch (event.type) {
    case MESSAGE:
      {
        var message = _extends({}, createEventBase(event), {
          type: event.type,
          text: event.text
        });

        if (event.postback) {
          message.postback = {
            id: event.postback.id,
            thread_id: event.postback.threadId,
            event_id: event.postback.eventId,
            type: event.postback.type,
            value: event.postback.value
          };
        }

        return message;
      }

    case FILE:
      {
        var file = _extends({}, createEventBase(event), {
          type: event.type,
          url: event.url
        });

        return file;
      }

    case FILLED_FORM:
      {
        var filledForm = _extends({}, createEventBase(event), {
          type: event.type,
          form_id: event.formId,
          fields: event.fields.map(function (field) {
            switch (field.type) {
              case 'group_chooser':
                {
                  if (!field.answer) {
                    return field;
                  }

                  var _field$answer = field.answer,
                      groupId = _field$answer.groupId,
                      answer = _objectWithoutPropertiesLoose(_field$answer, ["groupId"]);

                  return _extends({}, field, {
                    answer: _extends({}, answer, {
                      group_id: groupId
                    })
                  });
                }

              default:
                return field;
            }
          })
        });

        return filledForm;
      }

    case SYSTEM_MESSAGE:
      {
        var systemMessage = _extends({}, createEventBase(event), {
          type: event.type,
          text: event.text,
          system_message_type: event.systemMessageType
        });

        if (event.recipients) {
          systemMessage.recipients = event.recipients;
        }

        return systemMessage;
      }
  }
};

var parseThreadData = function parseThreadData(thread) {
  var data = {};
  var events = thread.events,
      properties = thread.properties;

  if (events) {
    data.events = events.map(parseEvent);
  }

  if (properties) {
    data.properties = properties;
  }

  return data;
};

var parseStartChatData = function parseStartChatData(_ref) {
  var chat = _ref.chat,
      continuous = _ref.continuous;
  var data = {
    chat: {}
  };

  if (typeof continuous === 'boolean') {
    data.continuous = continuous;
  }

  if (!chat) {
    return data;
  }

  var access = chat.access,
      thread = chat.thread,
      properties = chat.properties;

  if (access && access.groupIds) {
    data.chat.access = {
      group_ids: access.groupIds
    };
  }

  if (properties) {
    data.chat.properties = properties;
  }

  if (thread) {
    data.chat.thread = parseThreadData(thread);
  }

  return data;
};
var parseActivateChatData = function parseActivateChatData(requestData) {
  var data = parseStartChatData(requestData);
  return _extends({}, data, {
    chat: _extends({}, data.chat, {
      id: requestData.chat.id
    })
  });
};
var parseCustomerSessionFields = function parseCustomerSessionFields(sessionFields) {
  return toPairs(sessionFields).map(function (_ref2) {
    var _ref3;

    var key = _ref2[0],
        value = _ref2[1];
    return _ref3 = {}, _ref3[key] = value, _ref3;
  });
};
var parseCustomerUpdate = function parseCustomerUpdate(update) {
  var result = pickOwn(['avatar', 'name', 'email'], update);

  if (update.sessionFields) {
    result.session_fields = parseCustomerSessionFields(update.sessionFields);
  }

  return result;
};

var destroy = function destroy(reason) {
  return {
    type: DESTROY,
    payload: {
      reason: reason
    }
  };
};
var loginSuccess = function loginSuccess(payload) {
  return {
    type: LOGIN_SUCCESS,
    payload: payload
  };
};
var prefetchToken = function prefetchToken(fresh) {
  if (fresh === void 0) {
    fresh = false;
  }

  return {
    type: PREFETCH_TOKEN,
    payload: {
      fresh: fresh
    }
  };
};
var reconnect = function reconnect(delay) {
  return {
    type: RECONNECT,
    payload: {
      delay: delay
    }
  };
}; // TODO: this one was currently pretty hard to type in full
// we should explore providing stricter types for this in the future

var sendRequest = function sendRequest(action, payload, source) {
  return {
    type: SEND_REQUEST,
    payload: _extends({
      request: {
        action: action,
        payload: payload
      }
    }, source && {
      source: source
    })
  };
};
var sendEvent = function sendEvent(_ref) {
  var chatId = _ref.chatId,
      event = _ref.event,
      attachToLastThread = _ref.attachToLastThread;
  var payload = {
    chat_id: chatId,
    event: parseEvent(event)
  };

  if (attachToLastThread) {
    payload.attach_to_last_thread = true;
  }

  return sendRequest(SEND_EVENT, payload);
};
var setChatActive = function setChatActive(id, active) {
  return {
    type: SET_CHAT_ACTIVE,
    payload: {
      id: id,
      active: active
    }
  };
};
var setSelfId = function setSelfId(id) {
  return {
    type: SET_SELF_ID,
    payload: {
      id: id
    }
  };
};
var socketDisconnected = function socketDisconnected() {
  return {
    type: SOCKET_DISCONNECTED
  };
};

// TODO: this thing is not really well typed and should be improved
var sendRequestAction = function sendRequestAction(store, action) {
  action.payload.id = generateUniqueId(store.getState().requests);

  var _deferred = deferred(),
      resolve = _deferred.resolve,
      reject = _deferred.reject,
      promise = _deferred.promise;

  action.payload.promise = promise;
  action.payload.resolve = resolve;
  action.payload.reject = reject;
  store.dispatch(action);
  return promise;
};

var AUTHENTICATION = 'AUTHENTICATION';
var CUSTOMER_BANNED$1 = 'CUSTOMER_BANNED';
var USERS_LIMIT_REACHED = 'USERS_LIMIT_REACHED';
var WRONG_PRODUCT_VERSION = 'WRONG_PRODUCT_VERSION';

var getSideStorageKey = function getSideStorageKey(store) {
  var _store$getState = store.getState(),
      licenseId = _store$getState.licenseId,
      groupId = _store$getState.groupId,
      uniqueGroups = _store$getState.uniqueGroups;

  return "side_storage_" + licenseId + (uniqueGroups ? ":" + groupId : '');
};

var getSideStorage = function getSideStorage(store) {
  return storage.getItem(getSideStorageKey(store)).catch(noop).then(function (sideStorage) {
    return JSON.parse(sideStorage || '{}');
  }) // shouldnt get triggered, just a defensive measure against malformed storage entries
  .catch(function () {
    return {};
  });
};
var saveSideStorage = function saveSideStorage(store, sideStorage) {
  return storage.setItem(getSideStorageKey(store), JSON.stringify(sideStorage)).catch(noop);
};

var taskChain = function taskChain(_ref, onSuccess, onError) {
  var steps = _ref.slice(0);

  var cancelled = false;

  var next = function next(intermediateResult) {
    var step = steps.shift();
    promiseTry(function () {
      return step(intermediateResult);
    }).then(function (result) {
      if (cancelled) {
        return;
      }

      if (steps.length) {
        next(result);
        return;
      }

      onSuccess(result);
    }, function (error) {
      if (cancelled) {
        return;
      }

      onError(error);
    });
  };

  next();
  return {
    cancel: function cancel() {
      cancelled = true;
    }
  };
};

var sendLoginFlowRequest = function sendLoginFlowRequest(store, type, payload) {
  return sendRequestAction(store, sendRequest(type, payload, 'login'));
};

var delay = function delay(ms) {
  return new Promise(function (resolve) {
    setTimeout(resolve, ms);
  });
};

function createLoginTask(auth, customerDataProvider) {
  var store;
  var sentPage = null;
  var task;
  var backoff = new Backo({
    min: 300,
    max: 60000,
    jitter: 0.3
  });

  var destroy$$1 = function destroy$$1(reason) {
    return store.dispatch(destroy(reason));
  };

  var reconnect$$1 = function reconnect$$1() {
    return store.dispatch(reconnect(backoff.duration()));
  };

  var getTokenAndSideStorage = function getTokenAndSideStorage() {
    return Promise.all([auth.getToken(), getSideStorage(store)]);
  };

  var dispatchSelfId = function dispatchSelfId(_ref2) {
    var token = _ref2[0],
        sideStorage = _ref2[1];
    var selfId = getSelfId(store.getState());

    if (selfId === null) {
      store.dispatch(setSelfId(token.entityId));
    } else if (selfId !== token.entityId) {
      var err = new Error('Identity has changed.');
      err.code = IDENTITY_MISMATCH;
      throw err;
    }

    return [token, sideStorage];
  };

  var sendLogin = function sendLogin(_ref3) {
    var token = _ref3[0],
        sideStorage = _ref3[1];
    var state = store.getState();
    var application = state.application,
        groupId = state.groupId,
        page = state.page,
        referrer = state.referrer,
        mobile = state.mobile;
    var payload = {
      token: token.tokenType + " " + token.accessToken,
      customer: typeof customerDataProvider === 'function' ? parseCustomerUpdate(customerDataProvider()) : {},
      customer_side_storage: sideStorage,
      is_mobile: mobile,
      application: pick(['name', 'version'], application)
    };

    if (typeof groupId === 'number') {
      payload.group_id = groupId;
    }

    if (application.channelType) {
      payload.application.channel_type = application.channelType;
    }

    if (page !== null) {
      sentPage = page;
      payload.customer_page = page;
    }

    if (referrer !== null) {
      payload.referrer = referrer;
    }

    return Promise.race([sendLoginFlowRequest(store, LOGIN, payload), delay(15 * 1000).then(function () {
      return Promise.reject(createError({
        message: 'Request timed out.',
        code: REQUEST_TIMEOUT
      }));
    })]);
  };

  var updateCustomerPageIfNeeded = function updateCustomerPageIfNeeded() {
    var _store$getState = store.getState(),
        page = _store$getState.page;

    if (sentPage !== page) {
      sendLoginFlowRequest(store, UPDATE_CUSTOMER_PAGE$1, page).catch(noop);
    }

    sentPage = null;
  };

  return function (_store) {
    // after switching to callbags, we should be able to use smth similar to redux-observable
    // and thus just use store given to epic
    store = _store;

    if (task) {
      task.cancel();
    }

    task = taskChain([getTokenAndSideStorage, dispatchSelfId, sendLogin], function (loginResponse) {
      task = null;
      backoff.reset(); // TODO: rethink if this should be handled by SDK consumer

      updateCustomerPageIfNeeded();
      store.dispatch(loginSuccess(loginResponse));
    }, function (error) {
      if (process.env.NODE_ENV !== 'production') {
        console.error('[Customer SDK] Login flow has thrown code', error.code, 'with', error);
      }

      switch (error.code) {
        case AUTHENTICATION:
          auth.getFreshToken();
          reconnect$$1();
          return;

        case CONNECTION_LOST:
          // this is connectivity problem, not a server error
          // and is taken care of in socket module
          // as it has its own backoff implementation
          return;

        case MISDIRECTED_CONNECTION:
          // socket gets reinitialized on this anyway, so just ignore it here
          return;
        // those are auth errors, we should maybe export those constants from the auth package

        case 'SSO_IDENTITY_EXCEPTION':
        case 'SSO_OAUTH_EXCEPTION':
          if (error.message === 'server_error' || error.message === 'temporarily_unavailable') {
            reconnect$$1();
            return;
          }

          destroy$$1(error.message);
          return;

        case IDENTITY_MISMATCH:
        case CUSTOMER_BANNED$1:
        case USERS_LIMIT_REACHED:
        case WRONG_PRODUCT_VERSION:
          destroy$$1(error.code.toLowerCase());
          return;

        default:
          reconnect$$1();
          return;
      }
    });
  };
}

var checkGoals = function checkGoals(store, auth, sessionFields) {
  return auth.getToken().then(function (token) {
    var state = store.getState();

    if (getSelfId(state) === null) {
      store.dispatch(setSelfId(token.entityId));
    }

    var page = state.page;

    if (!page || !page.url) {
      return;
    }

    var query = buildQueryString({
      license_id: state.licenseId
    });
    var payload = {
      // TODO: remove sending customer_fields once API releases their changes
      customer_fields: sessionFields || {},
      session_fields: parseCustomerSessionFields(sessionFields || {}),
      group_id: state.groupId || 0,
      page_url: page.url
    };
    return unfetch(getServerUrl(state) + "/action/" + CHECK_GOALS$1 + "?" + query, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: token.tokenType + " " + token.accessToken
      },
      body: JSON.stringify(payload)
    }).then(function () {
      // TODO: we should actually normalize response here
      return undefined;
    });
  });
};

var failAllRequests = function failAllRequests(_ref, reason) {
  var getState = _ref.getState,
      dispatch = _ref.dispatch;
  var state = getState();
  var requests = getAllRequests(state);
  dispatch({
    type: FAIL_ALL_REQUESTS,
    payload: {
      rejects: Object.keys(requests).map(function (requestId) {
        return requests[requestId].reject;
      }),
      reason: reason
    }
  });
};
var failRequest = function failRequest(_ref2, requestAction, error) {
  var getState = _ref2.getState,
      dispatch = _ref2.dispatch;
  var requestId = requestAction.payload.id;
  dispatch({
    type: REQUEST_FAILED,
    payload: {
      id: requestId,
      reject: getState().requests[requestId].reject,
      error: error
    }
  });
};

var SUCCESS = Object.freeze({
  success: true
});

var parseCommonEventProps = function parseCommonEventProps(threadId, event) {
  var parsed = {
    id: event.id,
    authorId: event.author_id,
    createdAt: event.created_at,
    threadId: threadId,
    properties: event.properties || {}
  };

  if (event.custom_id !== undefined) {
    parsed.customId = event.custom_id;
  }

  return parsed;
};

var downsizeWithRatio = function downsizeWithRatio(max, dimensions) {
  var _ref;

  var biggerProp;
  var smallerProp;
  var bigger;
  var smaller;

  if (dimensions.height > dimensions.width) {
    biggerProp = 'height';
    smallerProp = 'width';
    bigger = dimensions.height;
    smaller = dimensions.width;
  } else {
    biggerProp = 'width';
    smallerProp = 'height';
    bigger = dimensions.width;
    smaller = dimensions.height;
  }

  var ratio = max / bigger;
  return _ref = {}, _ref[biggerProp] = Math.ceil(Math.min(bigger, max)), _ref[smallerProp] = Math.ceil(Math.min(ratio * smaller, smaller)), _ref;
};

var parseImage = function parseImage(thread, image) {
  return _extends({}, parseCommonEventProps(thread, image), {
    type: FILE,
    contentType: image.content_type,
    url: image.url,
    name: image.name,
    width: image.width,
    height: image.height,
    thumbnails: {
      default: _extends({
        url: image.thumbnail_url
      }, downsizeWithRatio(300, image)),
      high: _extends({
        url: image.thumbnail2x_url
      }, downsizeWithRatio(600, image))
    }
  });
};

var parseFile = function parseFile(thread, file) {
  if (file.width !== undefined && file.height !== undefined) {
    return parseImage(thread, file);
  }

  return _extends({}, parseCommonEventProps(thread, file), {
    type: FILE,
    contentType: file.content_type,
    url: file.url,
    name: file.name
  });
};
var parseFilledForm = function parseFilledForm(thread, filledForm) {
  return _extends({}, parseCommonEventProps(thread, filledForm), {
    type: FILLED_FORM,
    formId: filledForm.form_id,
    fields: filledForm.fields.map(function (field) {
      switch (field.type) {
        case 'group_chooser':
          {
            if (!field.answer) {
              return field;
            }

            var _field$answer = field.answer,
                groupId = _field$answer.group_id,
                answer = _objectWithoutPropertiesLoose(_field$answer, ["group_id"]);

            return _extends({}, field, {
              answer: _extends({}, answer, {
                groupId: groupId
              })
            });
          }

        default:
          return field;
      }
    })
  });
};
var parseMessage = function parseMessage(thread, message) {
  return _extends({}, parseCommonEventProps(thread, message), {
    type: MESSAGE,
    text: message.text
  });
};

var parseRichMessageElement = function parseRichMessageElement(element) {
  var parsed = {};

  if (typeof element.title === 'string') {
    parsed.title = element.title;
  }

  if (typeof element.subtitle === 'string') {
    parsed.subtitle = element.subtitle;
  }

  if (element.image) {
    // TODO: we should reuse parseImage here
    var image = element.image;
    parsed.image = {
      url: image.url,
      name: image.name
    };
  }

  if (element.buttons) {
    parsed.buttons = element.buttons.map(function (serverButton) {
      switch (serverButton.type) {
        case 'message':
        case 'phone':
          {
            return {
              type: serverButton.type,
              text: serverButton.text,
              postbackId: serverButton.postback_id,
              userIds: serverButton.user_ids,
              value: serverButton.value,
              role: serverButton.role || 'default'
            };
          }

        case 'url':
          {
            var button = {
              type: serverButton.type,
              text: serverButton.text,
              postbackId: serverButton.postback_id,
              userIds: serverButton.user_ids,
              value: serverButton.value,
              role: serverButton.role || 'default'
            };

            if (serverButton.target) {
              button.target = serverButton.target;
            }

            return button;
          }

        case 'webview':
          {
            var _button = {
              type: serverButton.type,
              text: serverButton.text,
              postbackId: serverButton.postback_id,
              userIds: serverButton.user_ids,
              value: serverButton.value,
              role: serverButton.role || 'default'
            };

            if (typeof serverButton.webview_height === 'string') {
              _button.webviewHeight = serverButton.webview_height;
            }

            return _button;
          }

        default:
          {
            return {
              text: serverButton.text,
              postbackId: serverButton.postback_id,
              userIds: serverButton.user_ids,
              role: serverButton.role || 'default'
            };
          }
      }
    });
  }

  return parsed;
};

var parseRichMessage = function parseRichMessage(thread, richMessage) {
  switch (richMessage.template_id) {
    case 'cards':
    case 'quick_replies':
    case 'sticker':
      return _extends({}, parseCommonEventProps(thread, richMessage), {
        type: RICH_MESSAGE,
        template: richMessage.template_id,
        elements: richMessage.elements.map(parseRichMessageElement)
      });

    default:
      return null;
  }
};
var parseSystemMessage = function parseSystemMessage(thread, systemMessage) {
  var parsed = _extends({}, parseCommonEventProps(thread, _extends({}, systemMessage, {
    author_id: 'system'
  })), {
    type: SYSTEM_MESSAGE,
    text: systemMessage.text,
    systemMessageType: systemMessage.system_message_type
  });

  if (systemMessage.text_vars) {
    parsed.textVars = systemMessage.text_vars;
  }

  return parsed;
};
var parseEvent$1 = function parseEvent(thread, event) {
  switch (event.type) {
    case FILE:
      return parseFile(thread, event);

    case FILLED_FORM:
      return parseFilledForm(thread, event);

    case MESSAGE:
      return parseMessage(thread, event);

    case RICH_MESSAGE:
      return parseRichMessage(thread, event);

    case SYSTEM_MESSAGE:
      return parseSystemMessage(thread, event);

    default:
      return null;
  }
};
var parseGreeting = function parseGreeting(greeting) {
  return {
    id: greeting.id,
    addon: greeting.addon || null,
    uniqueId: greeting.unique_id,
    displayedFirstTime: greeting.displayed_first_time,
    accepted: greeting.accepted || false,
    // threadId is typed as nonoptional string but for greetings it doesn't exist
    event: parseEvent$1(null, greeting.event),
    agent: {
      id: greeting.agent.id,
      name: greeting.agent.name,
      avatar: greeting.agent.avatar,
      jobTitle: greeting.agent.job_title,
      isBot: greeting.agent.is_bot || false
    }
  };
};

// so it's better to rely on a custom implementation

var parseCustomerSessionFields$1 = function parseCustomerSessionFields(sessionFields) {
  return sessionFields.reduce(function (acc, field) {
    var _Object$keys = Object.keys(field),
        key = _Object$keys[0];

    acc[key] = field[key];
    return acc;
  }, {});
};

var parseAccess = function parseAccess(access) {
  if (access === void 0) {
    access = {};
  }

  return access.group_ids ? {
    groupIds: access.group_ids
  } : {};
};
var getEventsSeenUpToMap = function getEventsSeenUpToMap(users) {
  return mapValues(function (user) {
    return user.events_seen_up_to ? user.events_seen_up_to : null;
  }, keyBy('id', users));
};
var parseThread = function parseThread(chatId, thread) {
  var properties = thread.properties || {};
  return {
    id: thread.id,
    chatId: chatId,
    active: thread.active,
    access: parseAccess(thread.access),
    createdAt: thread.created_at,
    userIds: thread.user_ids,
    events: thread.events.map(function (event) {
      return parseEvent$1(thread.id, event);
    }).filter(Boolean),
    properties: properties,
    previousThreadId: thread.previous_thread_id || null,
    nextThreadId: thread.next_thread_id || null,
    queue: thread.queue ? parseQueue(thread.queue) : null
  };
};
var parseIncomingChat = function parseIncomingChat(chat) {
  return {
    id: chat.id,
    access: parseAccess(chat.access),
    users: chat.users.map(parseChatUser),
    properties: chat.properties || {},
    thread: parseThread(chat.id, chat.thread),
    eventsSeenUpToMap: getEventsSeenUpToMap(chat.users)
  };
};
var parseChatAgent = function parseChatAgent(agent) {
  return {
    id: agent.id,
    // keep literal here, so every non-customer gets treated as agent
    // currently there are only 2 types of users - customer & agent (bots have type: "agent")
    // so this is purely defensive measure, trying to stay future-proof
    type: AGENT,
    name: agent.name,
    avatar: agent.avatar,
    jobTitle: agent.job_title,
    present: agent.present
  };
};
var parseCustomerOptionalProps = function parseCustomerOptionalProps(customerProps) {
  var optionalProps = pickOwn(['avatar', 'email', 'name'], customerProps);

  if (customerProps.session_fields) {
    optionalProps.sessionFields = parseCustomerSessionFields$1(customerProps.session_fields);
  }

  return optionalProps;
};

var parseCustomerCommonProps = function parseCustomerCommonProps(customer) {
  var optionalProps = parseCustomerOptionalProps(customer);
  return _extends({
    id: customer.id,
    type: CUSTOMER
  }, optionalProps, {
    sessionFields: optionalProps.sessionFields || {}
  });
};

var parseChatCustomer = function parseChatCustomer(customer) {
  return _extends({}, parseCustomerCommonProps(customer), {
    present: customer.present
  });
};
var parseCustomer = function parseCustomer(customer) {
  var statistics = customer.statistics;
  return _extends({}, parseCustomerCommonProps(customer), {
    statistics: {
      chatsCount: statistics.chats_count,
      threadsCount: statistics.threads_count,
      visitsCount: statistics.visits_count,
      pageViewsCount: statistics.page_views_count,
      greetingsShownCount: statistics.greetings_shown_count,
      greetingsAcceptedCount: statistics.greetings_accepted_count
    }
  });
};
var parsePredictedAgent = function parsePredictedAgent(agent) {
  return {
    id: agent.id,
    type: AGENT,
    name: agent.name,
    avatar: agent.avatar,
    jobTitle: agent.job_title,
    isBot: agent.is_bot
  };
};
var parseQueueUpdate = function parseQueueUpdate(queueUpdate) {
  return {
    position: queueUpdate.position,
    waitTime: queueUpdate.wait_time
  };
};
var parseQueue = function parseQueue(queue) {
  return _extends({}, parseQueueUpdate(queue), {
    queuedAt: queue.queued_at
  });
};
var parseChatUser = function parseChatUser(user) {
  return user.type === CUSTOMER ? parseChatCustomer(user) : parseChatAgent(user);
};
var parseGroupStatus = function parseGroupStatus(status) {
  return status === 'offline' ? 'offline' : 'online';
};

var _FAIL_ALL_REQUESTS_ME;

var SMALL_RECONNECT_DELAY = 100;
var FAIL_ALL_REQUESTS_MESSAGES = (_FAIL_ALL_REQUESTS_ME = {}, _FAIL_ALL_REQUESTS_ME[CONNECTION_LOST] = 'Connection lost.', _FAIL_ALL_REQUESTS_ME[MISDIRECTED_CONNECTION] = 'Connected to wrong region.', _FAIL_ALL_REQUESTS_ME);

var updateStateIfNeeded = function updateStateIfNeeded(store, action) {
  var state = store.getState();

  switch (action.type) {
    case PUSH_RESPONSE_RECEIVED:
    case PUSH_RECEIVED:
      switch (action.payload.action) {
        case CHAT_DEACTIVATED:
          store.dispatch(setChatActive(action.payload.payload.chatId, false));
          return;

        case INCOMING_CHAT:
          store.dispatch(setChatActive(action.payload.payload.chat.id, true));
          return;

        default:
          return;
      }

    case RESPONSE_RECEIVED:
      switch (action.payload.action) {
        case LIST_CHATS:
          action.payload.payload.chatsSummary.filter(function (_ref) {
            var id = _ref.id,
                active = _ref.active;
            return isChatActive(state, id) !== active;
          }).forEach(function (_ref2) {
            var id = _ref2.id,
                active = _ref2.active;
            store.dispatch(setChatActive(id, active));
          });
          return;

        default:
          return;
      }

  }
};

var sendRequest$1 = function sendRequest$$1(socket, _ref3) {
  var _ref3$payload = _ref3.payload,
      id = _ref3$payload.id,
      request = _ref3$payload.request;

  var frame = _extends({
    request_id: id
  }, request);

  socket.emit(frame);
};

var emitUsers = function emitUsers(emit, users) {
  users.forEach(function (user) {
    if ('present' in user) {
      var rest = _objectWithoutPropertiesLoose(user, ["present"]);

      emit('user_data', rest);
      return;
    }

    if (user.type === CUSTOMER) {
      var _rest = _objectWithoutPropertiesLoose(user, ["statistics"]);

      emit('user_data', _rest);
      return;
    }

    emit('user_data', user);
  });
};

var handleMulticast = function handleMulticast(emit, _ref4) {
  var type = _ref4.type,
      content = _ref4.content;

  if (type !== 'lc2') {
    return;
  }

  if (content.name === 'groups_update' && 'groups' in content && !isEmpty(content.groups)) {
    var _content$groups = content.groups,
        group = _content$groups[0];
    var availability = parseGroupStatus(group.status);
    emit('availability_updated', {
      availability: availability
    });
  }
};

var handlePush = function handlePush(_ref5, _ref6) {
  var emit = _ref5.emit,
      store = _ref5.store;
  var payload = _ref6.payload;

  switch (payload.action) {
    case THREAD_PROPERTIES_UPDATED:
      if (payload.payload.properties.lc2 && 'queue_pos' in payload.payload.properties.lc2) {
        emit(QUEUE_POSITION_UPDATED, {
          chatId: payload.payload.chatId,
          threadId: payload.payload.threadId,
          queue: {
            position: payload.payload.properties.lc2.queue_pos,
            waitTime: payload.payload.properties.lc2.queue_waiting_time
          }
        });
      }

      emit('thread_properties_updated', payload.payload);
      return;

    case CUSTOMER_SIDE_STORAGE_UPDATED:
      saveSideStorage(store, payload.payload.customer_side_storage);
      return;

    case CUSTOMER_DISCONNECTED:
      // each of those should currently lead to either reconnect or destroy call
      // after receiving this push server closes the connection with us
      // which results in SOCKET_DISCONNECTED action being dispatched
      // we don't want to rely on this (nor we want to risk emitting 'disconnected' twice)
      // so we should handle all cases ourselves and close the connection preemptively
      switch (payload.payload.reason) {
        case ACCESS_TOKEN_EXPIRED:
          // we passthrough access_token_expired here, so pending requests receive CONNECTION_LOST error
          // we could fail them with ACCESS_TOKEN_EXPIRED, but it could force people to handle it in special manner
          // but actually they should handle it exactly like CONNECTION_LOST:
          // a request could succeed, who knows, it has to be checked after being reconnected
          store.dispatch(prefetchToken(true));
          store.dispatch(reconnect(SMALL_RECONNECT_DELAY));
          emit('disconnected', payload.payload);
          break;

        case CUSTOMER_BANNED:
        case CUSTOMER_TEMPORARILY_BLOCKED:
        case LICENSE_NOT_FOUND:
        case PRODUCT_VERSION_CHANGED:
        case TOO_MANY_CONNECTIONS:
        case UNSUPPORTED_VERSION:
          // this also emits `disconnected` event - but it's handled in response to this action by destroy handler
          store.dispatch(destroy(payload.payload.reason));
          break;

        case MISDIRECTED_CONNECTION$1:
          failAllRequests(store, MISDIRECTED_CONNECTION);
          store.dispatch({
            type: CHANGE_REGION,
            payload: payload.payload.data
          });
          break;

        case TOO_MANY_UNAUTHORIZED_CONNECTIONS$1:
          // this should only really fail a `login` request - as it's the only one sent before authorization
          // and login should reconnect on its own right now
          failAllRequests(store, TOO_MANY_UNAUTHORIZED_CONNECTIONS);
          break;

        default:
          store.dispatch(reconnect(SMALL_RECONNECT_DELAY));
          emit('disconnected', payload.payload);
          break;
      }

      return;

    case INCOMING_CHAT:
      emitUsers(emit, payload.payload.chat.users);
      emit(payload.action, payload.payload);
      return;

    case INCOMING_EVENT:
      if (payload.payload.event === null) {
        return;
      }

      emit(payload.action, payload.payload);
      return;

    case INCOMING_TYPING_INDICATOR:
      emit(payload.action, payload.payload);
      return;

    case INCOMING_MULTICAST:
      handleMulticast(emit, payload.payload); // we passthrough this action even if it was already handled above

      emit(payload.action, payload.payload);
      return;

    case USER_ADDED_TO_CHAT:
      emitUsers(emit, [payload.payload.user]);
      emit(payload.action, payload.payload);
      return;

    default:
      emit(payload.action, payload.payload);
      return;
  }
};

var handleResponse = function handleResponse(_ref7, _ref8) {
  var emit = _ref7.emit;
  var payload = _ref8.payload;

  switch (payload.action) {
    case CHAT_DEACTIVATED:
      payload.resolve(SUCCESS);
      return;

    case GET_CHAT:
      emitUsers(emit, payload.payload.users);
      payload.resolve(payload.payload);
      return;

    case INCOMING_CHAT:
      emitUsers(emit, payload.payload.chat.users);
      payload.resolve(payload.payload);
      return;

    case INCOMING_EVENT:
      payload.resolve(payload.payload.event);
      return;

    case LIST_CHATS:
      emitUsers(emit, payload.payload.users);
      payload.resolve(payload.payload);
      return;

    default:
      payload.resolve(payload.payload);
      return;
  }
};

var createSideEffectsHandler = (function (_ref9) {
  var auth = _ref9.auth,
      customerDataProvider = _ref9.customerDataProvider,
      emitter = _ref9.emitter,
      socket = _ref9.socket;
  var emit = emitter.emit;
  var login = createLoginTask(auth, customerDataProvider); // TODO: using Store type here is a lie, middleware only provides MiddlewareAPI here

  return function (action, store) {
    switch (action.type) {
      case CHANGE_REGION:
        socket.reinitialize();
        return;

      case CHECK_GOALS:
        checkGoals(store, auth, action.payload.sessionFields).catch(noop);
        return;

      case DESTROY:
        {
          var payload = action.payload;
          socket.destroy();

          if (payload.reason !== 'manual') {
            emit('disconnected', payload);
          }

          emitter.off();
          return;
        }

      case FAIL_ALL_REQUESTS:
        {
          var _action$payload = action.payload,
              reason = _action$payload.reason,
              rejects = _action$payload.rejects;
          var error = {
            message: FAIL_ALL_REQUESTS_MESSAGES[reason],
            code: reason
          };
          rejects.forEach(function (reject) {
            reject(createError(error));
          });
          return;
        }

      case LOGIN_SUCCESS:
        {
          var _action$payload2 = action.payload,
              dynamicConfig = _action$payload2.dynamicConfig,
              customer = _action$payload2.customer,
              chats = _action$payload2.chats,
              greeting = _action$payload2.greeting,
              availability = _action$payload2.availability;

          var eventData = _extends({
            customer: customer,
            availability: availability
          }, greeting && {
            greeting: greeting
          });

          Object.defineProperty(eventData, '__unsafeDynamicConfig', {
            value: dynamicConfig
          });
          Object.defineProperty(eventData, '__unsafeChats', {
            value: chats
          });
          emit('connected', eventData);
          return;
        }

      case PAUSE_CONNECTION:
        socket.disconnect();
        return;

      case PREFETCH_TOKEN:
        if (action.payload.fresh) {
          auth.getFreshToken().catch(noop);
          return;
        }

        auth.hasToken().then(function (hasToken) {
          if (!hasToken) {
            return auth.getToken();
          }

          return auth.getToken().then(function (_ref10) {
            var creationDate = _ref10.creationDate,
                expiresIn = _ref10.expiresIn;
            var ONE_HOUR = 60 * 60 * 1000; // check if the token is worth reusing
            // we don't want to get disconnected in a moment because of expired token

            if (creationDate + expiresIn - Date.now() > ONE_HOUR) {
              return;
            }

            return auth.invalidate().then(auth.getFreshToken);
          });
        }).catch(noop);
        return;

      case PUSH_RECEIVED:
        // TODO: this if doesn't seem to make much sense
        // I'm too afraid to remove it right now though
        if (action.payload.action === CUSTOMER_DISCONNECTED) {
          handlePush({
            emit: emit,
            store: store
          }, action);
          return;
        }

        updateStateIfNeeded(store, action);
        handlePush({
          emit: emit,
          store: store
        }, action);
        return;

      case PUSH_RESPONSE_RECEIVED:
        updateStateIfNeeded(store, action);
        handleResponse({
          emit: emit
        }, action);
        return;

      case RECONNECT:
        socket.reconnect(action.payload.delay);
        return;

      case REQUEST_FAILED:
        {
          var _action$payload3 = action.payload,
              reject = _action$payload3.reject,
              _error = _action$payload3.error;
          reject(createError(_error));
          return;
        }

      case RESPONSE_RECEIVED:
        updateStateIfNeeded(store, action);
        handleResponse({
          emit: emit
        }, action);
        return;

      case SEND_REQUEST:
        {
          var state = store.getState();

          if (isDestroyed(state)) {
            failRequest(store, action, {
              code: 'SDK_DESTROYED',
              message: 'SDK destroyed.'
            });
            return;
          }

          if (!isConnected(state) && action.payload.source !== 'login') {
            failRequest(store, action, {
              code: 'NO_CONNECTION',
              message: 'No connection.'
            });
            return;
          }

          sendRequest$1(socket, action);
        }
        return;

      case SET_SELF_ID:
        emit('customer_id', action.payload.id);
        return;

      case SOCKET_DISCONNECTED:
        emit('disconnected', {
          reason: 'connection_lost'
        });
        return;

      case SOCKET_CONNECTED:
        login(store);
        return;

      case SOCKET_RECOVERED:
        // don't emit if from consumer's perspective we haven't been connected
        if (!isConnected(store.getState())) {
          return;
        }

        emit('connection_recovered');
        return;

      case SOCKET_UNSTABLE:
        // don't emit if from consumer's perspective we haven't been connected
        if (!isConnected(store.getState())) {
          return;
        }

        emit('connection_unstable');
        return;

      case START_CONNECTION:
        socket.connect();
        store.dispatch(prefetchToken());
        return;

      case UPDATE_CUSTOMER_PAGE:
        if (!isConnected(store.getState())) {
          return;
        }

        sendRequestAction(store, sendRequest(UPDATE_CUSTOMER_PAGE$1, action.payload)).catch(noop);
        return;

      default:
        return;
    }
  };
});

var HISTORY_EVENT_COUNT_TARGET = 25;

var createState = function createState() {
  return {
    status: 'idle',
    queuedTasks: [],
    nextPageId: null
  };
};

var createChatHistoryIterator = function createChatHistoryIterator(sdk, chatId) {
  var historyState = createState();

  var next = function next(resolve, reject) {
    switch (historyState.status) {
      case 'idle':
        historyState.status = 'fetching';
        sdk.listThreads({
          chatId: chatId,
          minEventsCount: HISTORY_EVENT_COUNT_TARGET,
          pageId: historyState.nextPageId || undefined
        }).then(function (_ref) {
          var threads = _ref.threads,
              nextPageId = _ref.nextPageId;
          historyState.nextPageId = nextPageId;

          if (!historyState.nextPageId) {
            historyState.status = 'done';
            resolve({
              value: {
                threads: [].concat(threads).reverse()
              },
              done: true
            });
          } else {
            historyState.status = 'idle';
            resolve({
              value: {
                threads: [].concat(threads).reverse()
              },
              done: false
            });
          }

          var queuedTask = historyState.queuedTasks.shift();

          if (!queuedTask) {
            return;
          }

          next(queuedTask.resolve, queuedTask.reject);
        }, function (err) {
          var queuedTasks = historyState.queuedTasks;
          historyState.status = 'idle';
          historyState.queuedTasks = [];
          reject(err);
          queuedTasks.forEach(function (queuedTask) {
            return queuedTask.reject(err);
          });
        });
        return;

      case 'fetching':
        historyState.queuedTasks.push({
          resolve: resolve,
          reject: reject
        });
        return;

      case 'done':
        resolve({
          value: undefined,
          done: true
        });
        return;
    }
  };

  return {
    next: function (_next) {
      function next() {
        return _next.apply(this, arguments);
      }

      next.toString = function () {
        return _next.toString();
      };

      return next;
    }(function () {
      return new Promise(next);
    })
  };
};

var initialize = function initialize(store, emitter) {
  var state = store.getState();
  var url = getServerUrl(state) + "/rtm/sjs";
  return createPlatformClient(url, {
    query: {
      license_id: state.licenseId
    },
    emitter: emitter
  });
};

var createSocketClient = function createSocketClient(store) {
  var emitter = mitt();
  var client = initialize(store, emitter);
  return _extends({}, Object.keys(client).reduce(function (proxy, method) {
    proxy[method] = function () {
      var _client;

      return (_client = client)[method].apply(_client, arguments);
    };

    return proxy;
  }, {}), {
    reinitialize: function reinitialize() {
      client.disconnect();
      client = initialize(store, emitter);
      client.connect();
    }
  });
};

var parseChatPropertiesDeletedPush = function parseChatPropertiesDeletedPush(payload) {
  return {
    chatId: payload.chat_id,
    properties: payload.properties
  };
};

var parseChatPropertiesUpdatedPush = function parseChatPropertiesUpdatedPush(payload) {
  return {
    chatId: payload.chat_id,
    properties: payload.properties
  };
};

var parseChatTransferredPush = function parseChatTransferredPush(payload) {
  var basePayload = {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    transferredTo: _extends({}, payload.transferred_to.agent_ids && {
      agentIds: payload.transferred_to.agent_ids
    }, payload.transferred_to.group_ids && {
      groupIds: payload.transferred_to.group_ids
    }),
    queue: payload.queue ? parseQueue(payload.queue) : null
  };

  if (payload.reason === 'manual') {
    return _extends({}, basePayload, {
      reason: payload.reason,
      requesterId: payload.requester_id
    });
  }

  return _extends({}, basePayload, {
    reason: payload.reason
  });
};

var parseCustomerPageUpdatedPush = function parseCustomerPageUpdatedPush(payload) {
  return {
    url: payload.url,
    title: payload.title,
    timestamp: payload.timestamp * 1000
  };
};

var parseCustomerUpdatedPush = function parseCustomerUpdatedPush(payload) {
  return {
    customer: _extends({
      id: payload.customer.id
    }, parseCustomerOptionalProps(payload.customer))
  };
};

var parseEventPropertiesDeletedPush = function parseEventPropertiesDeletedPush(payload) {
  return {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    eventId: payload.event_id,
    properties: payload.properties
  };
};

var parseEventPropertiesUpdatedPush = function parseEventPropertiesUpdatedPush(payload) {
  return {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    eventId: payload.event_id,
    properties: payload.properties
  };
};

var parseEventUpdatedPush = function parseEventUpdatedPush(payload) {
  var threadId = payload.thread_id;
  return {
    chatId: payload.chat_id,
    threadId: threadId,
    event: parseEvent$1(threadId, payload.event)
  };
};

var parseEventsMarkedAsSeenPush = function parseEventsMarkedAsSeenPush(payload) {
  return {
    chatId: payload.chat_id,
    userId: payload.user_id,
    seenUpTo: payload.seen_up_to
  };
};

var parseGreetingAcceptedPush = function parseGreetingAcceptedPush(payload) {
  return {
    uniqueId: payload.unique_id
  };
};

var parseGetChatResponse = function parseGetChatResponse(payload) {
  return parseIncomingChat(payload);
};

var parseIncomingChatPush = function parseIncomingChatPush(payload) {
  return {
    chat: parseIncomingChat(payload.chat)
  };
};

var parseIncomingEventPush = function parseIncomingEventPush(payload) {
  return {
    chatId: payload.chat_id,
    event: parseEvent$1(payload.thread_id, payload.event)
  };
};

var parseIncomingGreetingPush = function parseIncomingGreetingPush(payload) {
  return parseGreeting(payload);
};

var parseIncomingRichMessagePostbackPush = function parseIncomingRichMessagePostbackPush(payload) {
  return {
    userId: payload.user_id,
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    eventId: payload.event_id,
    postback: payload.postback
  };
};

var parseIncomingTypingIndicatorPush = function parseIncomingTypingIndicatorPush(payload) {
  var chatId = payload.chat_id,
      typingIndicator = payload.typing_indicator;
  return {
    chatId: chatId,
    typingIndicator: {
      authorId: typingIndicator.author_id,
      isTyping: typingIndicator.is_typing
    }
  };
};

var parseQueuePositionUpdatedPush = function parseQueuePositionUpdatedPush(payload) {
  return {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    queue: parseQueueUpdate(payload.queue)
  };
};

var parseThreadPropertiesDeletedPush = function parseThreadPropertiesDeletedPush(payload) {
  return {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    properties: payload.properties
  };
};

var parseThreadPropertiesUpdatedPush = function parseThreadPropertiesUpdatedPush(payload) {
  return {
    chatId: payload.chat_id,
    threadId: payload.thread_id,
    properties: payload.properties
  };
};

var parseUserAddedToChatPush = function parseUserAddedToChatPush(payload) {
  return {
    chatId: payload.chat_id,
    user: parseChatUser(payload.user),
    present: payload.user.present
  };
};

var parseUserRemovedFromChatPush = function parseUserRemovedFromChatPush(payload) {
  return {
    chatId: payload.chat_id,
    userId: payload.user_id
  };
};

var parseFields = function parseFields(fields) {
  return fields.map(function (field) {
    switch (field.type) {
      case 'group_chooser':
        return _extends({}, field, {
          options: field.options.map(function (_ref) {
            var groupId = _ref.group_id,
                option = _objectWithoutPropertiesLoose(_ref, ["group_id"]);

            return _extends({}, option, {
              groupId: groupId
            });
          })
        });

      case 'rating':
        {
          var commentLabel = field.comment_label,
              parsed = _objectWithoutPropertiesLoose(field, ["comment_label"]);

          return _extends({}, parsed, {
            commentLabel: commentLabel
          });
        }

      default:
        return field;
    }
  });
};

var parseTicketFormFields = function parseTicketFormFields(fields) {
  var withFakeIds = fields.map(function (field, index) {
    return _extends({}, field, {
      id: String(index)
    });
  });
  return parseFields(withFakeIds);
};

var parseGetFormResponse = function parseGetFormResponse(payload) {
  if (!payload.enabled) {
    return payload;
  }

  return _extends({}, payload, {
    form: 'id' in payload.form.fields[0] ? {
      id: payload.form.id,
      fields: parseFields(payload.form.fields)
    } : {
      // TODO: should we fake id for this one?
      id: 'ticket',
      fields: parseTicketFormFields(payload.form.fields)
    }
  });
};

var parseGetUrlInfoResponse = function parseGetUrlInfoResponse(payload) {
  var urlInfo = {
    url: payload.url
  };

  if (payload.title) {
    urlInfo.title = payload.title;
  }

  if (payload.description) {
    urlInfo.description = payload.description;
  }

  if (payload.image_url) {
    urlInfo.imageUrl = "https://" + payload.image_url;

    if (payload.image_width && payload.image_height) {
      urlInfo.imageWidth = payload.image_width;
      urlInfo.imageHeight = payload.image_height;
    }
  }

  return urlInfo;
};

var getAvailabilityBasedOnDynamicConfig = function getAvailabilityBasedOnDynamicConfig(_ref2) {
  var onlineGroups = _ref2.online_groups_ids,
      customerGroups = _ref2.customer_groups;

  // this might be missing if all groups are offline
  if (!onlineGroups) {
    return 'offline';
  }

  var monitoringGroupId = customerGroups.monitoring.id;
  return includes(monitoringGroupId, onlineGroups) ? 'online' : 'offline';
};

var parseListChatsResponse = function parseListChatsResponse(payload) {
  var chatsSummary = payload.chats_summary.map(function (_ref3) {
    var id = _ref3.id,
        active = _ref3.active,
        access = _ref3.access,
        lastThreadCreatedAt = _ref3.last_thread_created_at,
        lastThreadId = _ref3.last_thread_id,
        lastEventsPerType = _ref3.last_event_per_type,
        _ref3$properties = _ref3.properties,
        properties = _ref3$properties === void 0 ? {} : _ref3$properties,
        users = _ref3.users;
    var chatSummary = {
      id: id,
      active: active,
      access: parseAccess(access),
      properties: properties,
      users: users.map(parseChatUser),
      lastThreadId: lastThreadId || null,
      lastThreadCreatedAt: lastThreadCreatedAt || null,
      eventsSeenUpToMap: getEventsSeenUpToMap(users)
    };

    if (!lastEventsPerType) {
      return chatSummary;
    }

    chatSummary.lastEventsPerType = mapValues(function (lastEventPerType) {
      return parseEvent$1(lastEventPerType.thread_id, lastEventPerType.event);
    }, lastEventsPerType);
    var refinedLastEventsPerType = lastEventsPerType;
    var lastEventSummariesArray = Object.keys(refinedLastEventsPerType).map(function (eventType) {
      return refinedLastEventsPerType[eventType];
    });
    var lastEventSummary = last(lastEventSummariesArray.sort(function (eventSummaryA, eventSummaryB) {
      return eventSummaryA.thread_id === eventSummaryB.thread_id ? stringCompare(eventSummaryA.event.created_at, eventSummaryB.event.created_at) : stringCompare(eventSummaryA.thread_created_at, eventSummaryB.thread_created_at);
    }));

    if (lastEventSummary) {
      chatSummary.lastEvent = chatSummary.lastEventsPerType[lastEventSummary.event.type];
    }

    return chatSummary;
  });
  return {
    chatsSummary: numericSortBy(function (_ref4) {
      var lastEvent = _ref4.lastEvent,
          order = _ref4.order;
      return -1 * (lastEvent !== undefined ? lastEvent.timestamp : order);
    }, chatsSummary),
    totalChats: payload.total_chats,
    users: uniqBy(function (user) {
      return user.id;
    }, flatMap(function (summary) {
      return summary.users;
    }, chatsSummary)),
    previousPageId: payload.previous_page_id || null,
    nextPageId: payload.next_page_id || null
  };
};

var parseListGroupStatusesResponse = function parseListGroupStatusesResponse(payload) {
  return payload.groups_status;
};

var parseListThreadsResponse = function parseListThreadsResponse(request, payload) {
  return {
    threads: payload.threads.map(function (thread) {
      return parseThread(request.payload.chat_id, thread);
    }),
    previousPageId: payload.previous_page_id || null,
    nextPageId: payload.next_page_id || null
  };
};

var parseLoginResponse = function parseLoginResponse(payload) {
  var dynamicConfig = payload.__priv_dynamic_config,
      chats = payload.chats;
  var greeting = payload.greeting || dynamicConfig.greeting; // TODO: remove the fallback after API release the new greeting object position to the prod env

  return _extends({
    dynamicConfig: dynamicConfig,
    customer: parseCustomer(payload.customer),
    availability: getAvailabilityBasedOnDynamicConfig(dynamicConfig),
    chats: chats.map(function (chat) {
      return {
        id: chat.chat_id,
        active: 'has_active_thread' in chat ? chat.has_active_thread : // temporary fallback, waiting for API to move this flag into `chats` array
        payload.has_active_thread,
        hasUnreadEvents: chat.has_unread_events
      };
    })
  }, greeting && {
    greeting: parseGreeting(greeting)
  });
};

var parsePush = function parsePush(push) {
  switch (push.action) {
    case CHAT_DEACTIVATED:
      return {
        action: push.action,
        payload: {
          chatId: push.payload.chat_id
        }
      };

    case CHAT_PROPERTIES_DELETED:
      return {
        action: push.action,
        payload: parseChatPropertiesDeletedPush(push.payload)
      };

    case CHAT_PROPERTIES_UPDATED:
      return {
        action: push.action,
        payload: parseChatPropertiesUpdatedPush(push.payload)
      };

    case CHAT_TRANSFERRED:
      return {
        action: push.action,
        payload: parseChatTransferredPush(push.payload)
      };

    case CUSTOMER_SIDE_STORAGE_UPDATED:
      return {
        action: push.action,
        payload: push.payload
      };

    case CUSTOMER_DISCONNECTED:
      return {
        action: push.action,
        payload: push.payload
      };

    case CUSTOMER_PAGE_UPDATED:
      return {
        action: push.action,
        payload: parseCustomerPageUpdatedPush(push.payload)
      };

    case CUSTOMER_UPDATED:
      return {
        action: push.action,
        payload: parseCustomerUpdatedPush(push.payload)
      };

    case EVENT_PROPERTIES_DELETED:
      return {
        action: push.action,
        payload: parseEventPropertiesDeletedPush(push.payload)
      };

    case EVENT_PROPERTIES_UPDATED:
      return {
        action: push.action,
        payload: parseEventPropertiesUpdatedPush(push.payload)
      };

    case EVENT_UPDATED:
      return {
        action: push.action,
        payload: parseEventUpdatedPush(push.payload)
      };

    case EVENTS_MARKED_AS_SEEN:
      return {
        action: push.action,
        payload: parseEventsMarkedAsSeenPush(push.payload)
      };

    case GREETING_ACCEPTED:
      return {
        action: push.action,
        payload: parseGreetingAcceptedPush(push.payload)
      };

    case GREETING_CANCELED:
      return {
        action: push.action,
        // 'greeting_canceled' has the same payload as `greeting_accepted`
        payload: parseGreetingAcceptedPush(push.payload)
      };

    case INCOMING_CHAT:
      return {
        action: push.action,
        payload: parseIncomingChatPush(push.payload)
      };

    case INCOMING_EVENT:
      return {
        action: push.action,
        payload: parseIncomingEventPush(push.payload)
      };

    case INCOMING_GREETING:
      return {
        action: push.action,
        payload: parseIncomingGreetingPush(push.payload)
      };

    case INCOMING_MULTICAST:
      return {
        action: push.action,
        payload: push.payload
      };

    case INCOMING_RICH_MESSAGE_POSTBACK:
      return {
        action: push.action,
        payload: parseIncomingRichMessagePostbackPush(push.payload)
      };

    case INCOMING_TYPING_INDICATOR:
      return {
        action: push.action,
        payload: parseIncomingTypingIndicatorPush(push.payload)
      };

    case QUEUE_POSITION_UPDATED:
      return {
        action: push.action,
        payload: parseQueuePositionUpdatedPush(push.payload)
      };

    case THREAD_PROPERTIES_DELETED:
      return {
        action: push.action,
        payload: parseThreadPropertiesDeletedPush(push.payload)
      };

    case THREAD_PROPERTIES_UPDATED:
      return {
        action: push.action,
        payload: parseThreadPropertiesUpdatedPush(push.payload)
      };

    case USER_ADDED_TO_CHAT:
      return {
        action: push.action,
        payload: parseUserAddedToChatPush(push.payload)
      };

    case USER_REMOVED_FROM_CHAT:
      return {
        action: push.action,
        payload: parseUserRemovedFromChatPush(push.payload) // TODO: remove those once we sync with the API on prod

      };

    case 'chat_user_added':
      return {
        action: USER_ADDED_TO_CHAT,
        payload: parseUserAddedToChatPush(push.payload)
      };

    case 'chat_user_removed':
      return {
        action: USER_REMOVED_FROM_CHAT,
        payload: parseUserRemovedFromChatPush(push.payload)
      };
  }
};
var parseResponse = function parseResponse(_ref5) {
  var request = _ref5.request,
      response = _ref5.response;

  switch (response.action) {
    case ACCEPT_GREETING:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case CANCEL_GREETING:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case DELETE_CHAT_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case DELETE_EVENT_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case DELETE_THREAD_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case GET_CHAT:
      return {
        action: response.action,
        payload: parseGetChatResponse(response.payload)
      };

    case GET_CUSTOMER:
      return {
        action: response.action,
        payload: parseCustomer(response.payload)
      };

    case GET_FORM:
      return {
        action: response.action,
        payload: parseGetFormResponse(response.payload)
      };

    case GET_PREDICTED_AGENT:
      return {
        action: response.action,
        payload: parsePredictedAgent(response.payload)
      };

    case GET_URL_INFO:
      return {
        action: response.action,
        payload: parseGetUrlInfoResponse(response.payload)
      };

    case LIST_CHATS:
      return {
        action: response.action,
        payload: parseListChatsResponse(response.payload)
      };

    case LIST_GROUP_STATUSES:
      return {
        action: response.action,
        payload: parseListGroupStatusesResponse(response.payload)
      };

    case LIST_THREADS:
      return {
        action: response.action,
        payload: parseListThreadsResponse(request, response.payload)
      };

    case LOGIN:
      return {
        action: response.action,
        payload: parseLoginResponse(response.payload)
      };

    case MARK_EVENTS_AS_SEEN:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case SEND_SNEAK_PEEK:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case SET_CUSTOMER_SESSION_FIELDS:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case SEND_RICH_MESSAGE_POSTBACK:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case UPDATE_CHAT_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case UPDATE_CUSTOMER:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case UPDATE_CUSTOMER_PAGE$1:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case UPDATE_EVENT_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };

    case UPDATE_THREAD_PROPERTIES:
      return {
        action: response.action,
        payload: SUCCESS
      };
  }
};
var parseServerError = function parseServerError(error) {
  return {
    code: error.type.toUpperCase(),
    message: error.message
  };
};

var handleResponseError = function handleResponseError(_ref, response) {
  var dispatch = _ref.dispatch,
      getState = _ref.getState;
  var requestId = response.request_id,
      payload = response.payload;

  var _getRequest = getRequest(getState(), requestId),
      reject = _getRequest.reject;

  dispatch({
    type: REQUEST_FAILED,
    payload: {
      id: requestId,
      reject: reject,
      error: parseServerError(payload.error)
    }
  });
};

var handleResponse$1 = function handleResponse(_ref2, response) {
  var dispatch = _ref2.dispatch,
      getState = _ref2.getState;
  var requestId = response.request_id;

  var _getRequest2 = getRequest(getState(), requestId),
      promise = _getRequest2.promise,
      resolve = _getRequest2.resolve,
      request = _getRequest2.request;

  var parsedResponse = parseResponse({
    request: request,
    response: response
  });
  dispatch({
    type: RESPONSE_RECEIVED,
    payload: _extends({
      id: requestId,
      promise: promise,
      resolve: resolve
    }, parsedResponse)
  });
};

var handlePushResponse = function handlePushResponse(_ref3, response) {
  var dispatch = _ref3.dispatch,
      getState = _ref3.getState;
  var requestId = response.request_id;

  var _getRequest3 = getRequest(getState(), requestId),
      promise = _getRequest3.promise,
      resolve = _getRequest3.resolve;

  var parsedPush = parsePush(response);
  dispatch({
    type: PUSH_RESPONSE_RECEIVED,
    payload: _extends({
      id: requestId,
      promise: promise,
      resolve: resolve
    }, parsedPush)
  });
};

var handlePush$1 = function handlePush(store, push) {
  var parsedPush = parsePush(push);

  if (!parsedPush) {
    // defensive measure against receiving unknown push
    return;
  }

  store.dispatch({
    type: PUSH_RECEIVED,
    payload: parsedPush
  });
};

var socketListener = (function (store, socket) {
  var dispatch = store.dispatch;
  socket.on('connect', function () {
    dispatch({
      type: SOCKET_CONNECTED
    });
  });
  socket.on('message', function (message) {
    if (message.type === 'response') {
      if (!message.success) {
        handleResponseError(store, message);
        return;
      }

      switch (message.action) {
        case ACTIVATE_CHAT:
        case DEACTIVATE_CHAT:
        case SEND_EVENT:
        case START_CHAT:
          // those are requests with indirect responses
          return;

        default:
          handleResponse$1(store, message);
          return;
      }
    }

    if ('request_id' in message) {
      switch (message.action) {
        case CHAT_DEACTIVATED:
        case INCOMING_CHAT:
        case INCOMING_EVENT:
          // those are acting as indirect responses
          handlePushResponse(store, message);
          return;
      }
    }

    handlePush$1(store, message);
  });
  socket.on('disconnect', function () {
    failAllRequests(store, CONNECTION_LOST);

    if (getConnectionStatus(store.getState()) === CONNECTED) {
      store.dispatch(socketDisconnected());
    }
  });
  socket.on('connection_unstable', function () {
    dispatch({
      type: SOCKET_UNSTABLE
    });
  });
  socket.on('connection_recovered', function () {
    dispatch({
      type: SOCKET_RECOVERED
    });
  });
  return socket.off;
});

var INCORRECT_REQUESTER_STRUCTURE = 'incorrect requester structure';

var appendString = function appendString(input, str) {
  return input.length ? input + "\n" + str : str;
};

var createTicketBody = function createTicketBody(state, _ref) {
  var fields = _ref.fields,
      customerId = _ref.customerId,
      _ref$groupId = _ref.groupId,
      groupId = _ref$groupId === void 0 ? state.groupId : _ref$groupId,
      timeZone = _ref.timeZone;

  var ticketBody = _extends({
    licence_id: state.licenseId,
    ticket_message: '',
    offline_message: '',
    visitor_id: customerId,
    requester: {}
  }, typeof groupId === 'number' && {
    group: groupId
  }, state.page && {
    source: {
      url: state.page.url
    }
  }, timeZone && {
    timezone: timeZone
  });

  return fields.reduce(function (body, field) {
    switch (field.type) {
      case 'subject':
        {
          var value = field.answer;
          var text = value ? field.label + " " + value : field.label;

          if (value) {
            body.subject = value;
          }

          body.offline_message = appendString(body.offline_message, text);
          return body;
        }

      case 'name':
        {
          var _value = field.answer;

          var _text = _value ? field.label + " " + _value : field.label;

          if (_value) {
            body.requester.name = _value;
          }

          body.offline_message = appendString(body.offline_message, _text);
          return body;
        }

      case 'email':
        {
          var _value2 = field.answer;

          var _text2 = _value2 ? field.label + " " + _value2 : field.label;

          body.requester.mail = _value2;
          body.offline_message = appendString(body.offline_message, _text2);
          return body;
        }

      case 'question':
      case 'textarea':
        {
          var _value3 = field.answer;

          var _text3 = _value3 ? field.label + " " + _value3 : field.label;

          body.offline_message = appendString(body.offline_message, _text3);
          body.ticket_message = appendString(body.ticket_message, _text3);
          return body;
        }

      case 'radio':
      case 'select':
        {
          var _value4 = field.answer && field.answer.label;

          var _text4 = _value4 ? field.label + " " + _value4 : field.label;

          body.offline_message = appendString(body.offline_message, _text4);
          body.ticket_message = appendString(body.ticket_message, _text4);
          return body;
        }

      case 'checkbox':
        {
          var _value5 = field.answers && field.answers.map(function (answer) {
            return answer.label;
          }).join(', ');

          var _text5 = _value5 ? field.label + " " + _value5 : field.label;

          body.offline_message = appendString(body.offline_message, _text5);
          body.ticket_message = appendString(body.ticket_message, _text5);
          return body;
        }

      default:
        return body;
    }
  }, ticketBody);
};

var sendTicketForm = function sendTicketForm(store, auth, _ref2) {
  var filledForm = _ref2.filledForm,
      groupId = _ref2.groupId,
      timeZone = _ref2.timeZone;
  return auth.getToken().then(function (token) {
    var state = store.getState();

    if (getSelfId(state) === null) {
      store.dispatch(setSelfId(token.entityId));
    }

    var url = getApiOrigin(state) + "/v2/tickets/new";
    var body = createTicketBody(state, {
      fields: filledForm.fields,
      customerId: token.entityId,
      groupId: groupId,
      timeZone: timeZone
    });
    return unfetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    }).then(function (response) {
      if (response.ok) {
        return response.json().then(function (res) {
          return _extends({}, res, {
            text: body.ticket_message
          });
        });
      } // we actually should normalize this somehow


      if (response.status === 400 || response.status === 422) {
        var errHandler = function errHandler(error) {
          if (!error || !error.errors) {
            // TODO: I honestly don't know if this can even be reached and even if it is - What error should be thrown here
            throw new Error();
          } // we receive some hardcore aggregate error here 😱


          var firstError = error.errors[0];
          var type = Object.keys(firstError)[0];

          if (type === INCORRECT_REQUESTER_STRUCTURE) {
            throw createError({
              message: firstError[INCORRECT_REQUESTER_STRUCTURE][0],
              code: 'VALIDATION'
            });
          }

          throw new Error();
        };

        return response.json().then(errHandler, errHandler);
      }

      throw new Error();
    });
  });
};

var KILOBYTE = 1024;
var MEGABYTE = 1024 * KILOBYTE;
var GIGABYTE = 1024 * MEGABYTE;
var SIZE_LIMIT = 10 * MEGABYTE;

var formatBytes = function formatBytes(bytes, precision) {
  if (precision === void 0) {
    precision = 2;
  }

  if (bytes < KILOBYTE) {
    return bytes + " b";
  }

  var kilobytes = bytes / 1024;

  if (bytes < MEGABYTE) {
    return kilobytes.toFixed(precision) + " kb";
  }

  var megabytes = kilobytes / 1024;

  if (bytes < GIGABYTE) {
    return megabytes.toFixed(precision) + " MB";
  }

  var gigabytes = megabytes / 1024;
  return gigabytes.toFixed(precision) + " GB";
};

var validateFile = function validateFile(file) {
  if (file.size > SIZE_LIMIT) {
    throw createError({
      message: "The file is too big (max size is " + formatBytes(SIZE_LIMIT) + ").",
      code: 'TOO_BIG_FILE'
    });
  }
};

var uploadFile = function uploadFile(_ref, _ref2) {
  var auth = _ref.auth,
      store = _ref.store;
  var file = _ref2.file,
      onProgress = _ref2.onProgress;
  var upload;
  var cancelled = false;
  var send = new Promise(function (resolve, reject) {
    validateFile(file);
    var state = store.getState();
    var query = buildQueryString({
      license_id: state.licenseId
    });
    var url = getServerUrl(state) + "/action/" + UPLOAD_FILE + "?" + query;
    var payload = {
      file: file
    };
    auth.getToken().then(function (token) {
      if (cancelled) {
        reject(new Error('Upload cancelled.'));
        return;
      }

      upload = rawUploadFile(url, payload, {
        headers: {
          Authorization: token.tokenType + " " + token.accessToken
        },
        onProgress: onProgress
      });
      upload.promise.then(resolve, function (uploadError) {
        // an error might not come from a server
        if (!uploadError.response) {
          reject(uploadError);
          return;
        }

        var _uploadError$response = uploadError.response.error,
            type = _uploadError$response.type,
            message = _uploadError$response.message;
        reject(createError({
          message: message,
          code: type.toUpperCase()
        }));
      });
    });
  });
  return {
    promise: send,
    cancel: function cancel() {
      if (cancelled) {
        return;
      }

      cancelled = true;

      if (upload) {
        upload.cancel();
      }
    }
  };
};

var makeGraylogRequest = function makeGraylogRequest(url, body) {
  return new Promise(function (resolve) {
    var img = new Image();
    img.src = url + "?" + body;
    img.onerror = noop;

    img.onload = function () {
      return resolve();
    };
  });
};

/**
 * Logs event to Graylog with provided config data.
 * Logging request is fired only when all of those conditions are true:
 * 1. package is used in lc production environment
 * 2. package is used standalone because only then "customer_sdk" will be set to customer_sdk
 */
var log = function log(_ref) {
  var env = _ref.env,
      licenseId = _ref.licenseId,
      eventName = _ref.eventName;

  if (env !== 'production' || "customer_sdk" !== 'customer_sdk') {
    return Promise.resolve();
  }

  var message = {
    event_name: eventName,
    severity: 'Informational',
    sdkVersion: "2.0.4"
  };
  var body = {
    licence_id: licenseId,
    event_id: 'chat_widget_customer_sdk',
    message: JSON.stringify(message)
  };
  return makeGraylogRequest('https://queue.livechatinc.com/logs', buildQueryString(body));
};

var LISTENER_IDENTITY = 'LISTENER_IDENTITY';
var listenersMap = {};

var createDebuggedMethods = function createDebuggedMethods(methods, prefix) {
  if (prefix === void 0) {
    prefix = '';
  }

  var methodNames = Object.keys(methods);
  return methodNames.map(function (methodName) {
    var method = methods[methodName];
    return function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console).info.apply(_console, [prefix + "." + methodName + "() ===>"].concat(args));

      var result = method.apply(void 0, args);

      if (result && typeof result.then === 'function') {
        result.then(function (data) {
          console.info(prefix + "." + methodName + "() <===", data);
        }).catch(function (err) {
          console.error(prefix + "." + methodName + "() <===", err);
        });
      }

      return result;
    };
  }).reduce(function (acc, method, index) {
    acc[methodNames[index]] = method;
    return acc;
  }, {});
};

var createEnhancedListener = function createEnhancedListener(label, event, listener) {
  if (listener[LISTENER_IDENTITY] === undefined) {
    Object.defineProperty(listener, LISTENER_IDENTITY, {
      value: {}
    });
  }

  if (listener[LISTENER_IDENTITY][event]) {
    var enhancedListenerId = listener[LISTENER_IDENTITY][event];
    return listenersMap[enhancedListenerId];
  }

  var enhancedListener = function enhancedListener(data) {
    console.info("." + label + "(\"" + event + "\") <===", data);
    listener(data);
  };

  var uniqueId = generateUniqueId(listenersMap);
  listener[LISTENER_IDENTITY][event] = uniqueId;
  listenersMap[uniqueId] = enhancedListener;
  return enhancedListener;
}; // TODO: this really should just accept & return CustomerSdk type


var debug = (function (_sdk) {
  var sdk = _sdk;

  if (process.env.NODE_ENV === 'production') {
    console.warn('You probably do not want to use debug(customerSDK) in your production environment.');
  }

  var _on = sdk.on,
      _once = sdk.once,
      _off = sdk.off,
      _getChatHistory = sdk.getChatHistory,
      auth = sdk.auth,
      rest = _objectWithoutPropertiesLoose(sdk, ["on", "once", "off", "getChatHistory", "auth"]);

  var methods = createDebuggedMethods(rest);
  return Object.freeze(_extends({
    auth: Object.freeze(createDebuggedMethods(auth, '.auth'))
  }, methods, {
    getChatHistory: function getChatHistory() {
      var _console2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_console2 = console).info.apply(_console2, [".getChatHistory()"].concat(args));

      var history = _getChatHistory.apply(void 0, args);

      var logLabel = 'history.next()';
      return {
        next: function next() {
          var _console3;

          (_console3 = console).info.apply(_console3, [logLabel + " ===>"].concat(args));

          var result = history.next();
          result.then(function (data) {
            var _console4;

            (_console4 = console).info.apply(_console4, [logLabel + " <==="].concat(args, [data]));
          }).catch(function (err) {
            var _console5;

            (_console5 = console).error.apply(_console5, [logLabel + " <==="].concat(args, [err]));
          });
          return result;
        }
      };
    },
    off: function off(event, listener) {
      console.info(".off(\"" + event + "\", " + (listener.name || 'anonymous') + ")");
      var enhancedListener = listener;

      if (listener[LISTENER_IDENTITY] !== undefined) {
        var enhancedListenerId = listener[LISTENER_IDENTITY][event];
        enhancedListener = listenersMap[enhancedListenerId];
      }

      _off(event, enhancedListener);
    },
    on: function on(event, listener) {
      _on(event, createEnhancedListener('on', event, listener));
    },
    once: function once(event, listener) {
      _once(event, createEnhancedListener('once', event, listener));
    }
  }));
});

var CHATS_PAGINATION_MAX_LIMIT = 25;
var init = function init(config, env) {
  if (env === void 0) {
    env = 'production';
  }

  validateConfig(config);

  var _config$autoConnect = config.autoConnect,
      autoConnect = _config$autoConnect === void 0 ? true : _config$autoConnect,
      customerDataProvider = config.customerDataProvider,
      instanceConfig = _objectWithoutPropertiesLoose(config, ["autoConnect", "customerDataProvider"]);

  var store = finalCreateStore(_extends({}, instanceConfig, {
    env: env
  }));
  var emitter = mitt();
  var socket = createSocketClient(store);
  var auth = createAuth(instanceConfig, env);
  store.addSideEffectsHandler(createSideEffectsHandler({
    emitter: emitter,
    socket: socket,
    auth: auth,
    customerDataProvider: customerDataProvider
  }));
  socketListener(store, socket);

  var sendRequestAction$$1 = sendRequestAction.bind(null, store);

  var startConnection = function startConnection() {
    store.dispatch({
      type: START_CONNECTION
    });
  };

  var api = Object.freeze({
    acceptGreeting: function acceptGreeting(_ref) {
      var greetingId = _ref.greetingId,
          uniqueId = _ref.uniqueId;
      return sendRequestAction$$1(sendRequest(ACCEPT_GREETING, {
        greeting_id: greetingId,
        unique_id: uniqueId
      }));
    },
    activateChat: function activateChat(data) {
      log({
        env: env,
        licenseId: config.licenseId,
        eventName: 'chat_started'
      });
      return sendRequestAction$$1(sendRequest(ACTIVATE_CHAT, parseActivateChatData(data)));
    },
    auth: auth,
    cancelGreeting: function cancelGreeting(_ref2) {
      var uniqueId = _ref2.uniqueId;
      return sendRequestAction$$1(sendRequest(CANCEL_GREETING, {
        unique_id: uniqueId
      }));
    },
    cancelRate: function cancelRate(params) {
      var chatId = params.chatId,
          _params$properties = params.properties,
          properties = _params$properties === void 0 ? ['score'] : _params$properties;
      return api.listThreads({
        chatId: chatId
      }).then(function (_ref3) {
        var threads = _ref3.threads;

        if (!threads.length) {
          throw createError({
            message: "There is no thread in \"" + chatId + "\".",
            code: MISSING_CHAT_THREAD
          });
        }

        return api.deleteThreadProperties({
          chatId: chatId,
          threadId: threads[0].id,
          properties: {
            rating: properties
          }
        });
      });
    },
    connect: startConnection,
    deactivateChat: function deactivateChat(_ref4) {
      var chatId = _ref4.chatId;
      return sendRequestAction$$1(sendRequest(DEACTIVATE_CHAT, {
        chat_id: chatId
      }));
    },
    deleteChatProperties: function deleteChatProperties(_ref5) {
      var chatId = _ref5.chatId,
          properties = _ref5.properties;
      return sendRequestAction$$1(sendRequest(DELETE_CHAT_PROPERTIES, {
        chat_id: chatId,
        properties: properties
      }));
    },
    deleteEventProperties: function deleteEventProperties(_ref6) {
      var chatId = _ref6.chatId,
          threadId = _ref6.threadId,
          eventId = _ref6.eventId,
          properties = _ref6.properties;
      return sendRequestAction$$1(sendRequest(DELETE_EVENT_PROPERTIES, {
        chat_id: chatId,
        thread_id: threadId,
        event_id: eventId,
        properties: properties
      }));
    },
    deleteThreadProperties: function deleteThreadProperties(_ref7) {
      var chatId = _ref7.chatId,
          threadId = _ref7.threadId,
          properties = _ref7.properties;
      return sendRequestAction$$1(sendRequest(DELETE_THREAD_PROPERTIES, {
        chat_id: chatId,
        thread_id: threadId,
        properties: properties
      }));
    },
    destroy: function destroy$$1() {
      store.dispatch(destroy('manual'));
    },
    disconnect: function disconnect() {
      store.dispatch({
        type: PAUSE_CONNECTION
      });
    },
    getChat: function getChat(_ref8) {
      var chatId = _ref8.chatId,
          threadId = _ref8.threadId;
      return sendRequestAction$$1(sendRequest(GET_CHAT, {
        chat_id: chatId,
        thread_id: threadId
      }));
    },
    getChatHistory: function getChatHistory(_ref9) {
      var chatId = _ref9.chatId;
      return createChatHistoryIterator(api, chatId);
    },
    getCustomer: function getCustomer() {
      return sendRequestAction$$1(sendRequest(GET_CUSTOMER, {}));
    },
    getForm: function getForm(_ref10) {
      var groupId = _ref10.groupId,
          type = _ref10.type;
      return sendRequestAction$$1(sendRequest(GET_FORM, {
        group_id: groupId,
        type: type
      }));
    },
    getPredictedAgent: function getPredictedAgent(params) {
      if (params === void 0) {
        params = {};
      }

      var _params = params,
          groupId = _params.groupId;
      return sendRequestAction$$1(sendRequest(GET_PREDICTED_AGENT, typeof groupId === 'number' ? {
        group_id: groupId
      } : {}));
    },
    getUrlInfo: function getUrlInfo(_ref11) {
      var url = _ref11.url;
      return sendRequestAction$$1(sendRequest(GET_URL_INFO, {
        url: url
      }));
    },
    listChats: function listChats(_temp) {
      var _ref12 = _temp === void 0 ? {} : _temp,
          _ref12$limit = _ref12.limit,
          limit = _ref12$limit === void 0 ? 10 : _ref12$limit,
          pageId = _ref12.pageId;

      if (limit > CHATS_PAGINATION_MAX_LIMIT) {
        return Promise.reject(new Error("Specified limit is too high (max " + CHATS_PAGINATION_MAX_LIMIT + ")."));
      }

      return sendRequestAction$$1(sendRequest(LIST_CHATS, {
        limit: limit,
        page_id: pageId
      }));
    },
    listGroupStatuses: function listGroupStatuses(_temp2) {
      var _ref13 = _temp2 === void 0 ? {} : _temp2,
          groupIds = _ref13.groupIds;

      return sendRequestAction$$1(sendRequest(LIST_GROUP_STATUSES, groupIds ? {
        group_ids: groupIds
      } : {
        all: true
      }));
    },
    listThreads: function listThreads(_ref14) {
      var chatId = _ref14.chatId,
          _ref14$sortOrder = _ref14.sortOrder,
          sortOrder = _ref14$sortOrder === void 0 ? DESC : _ref14$sortOrder,
          limit = _ref14.limit,
          pageId = _ref14.pageId,
          minEventsCount = _ref14.minEventsCount;
      return sendRequestAction$$1(sendRequest(LIST_THREADS, {
        chat_id: chatId,
        sort_order: sortOrder,
        limit: limit,
        page_id: pageId,
        min_events_count: minEventsCount
      }));
    },
    markEventsAsSeen: function markEventsAsSeen(_ref15) {
      var chatId = _ref15.chatId,
          seenUpTo = _ref15.seenUpTo;
      return sendRequestAction$$1(sendRequest(MARK_EVENTS_AS_SEEN, {
        chat_id: chatId,
        seen_up_to: seenUpTo
      }));
    },
    on: emitter.on,
    once: emitter.once,
    off: emitter.off,
    rateChat: function rateChat(params) {
      var chatId = params.chatId,
          rating = params.rating;
      return api.listThreads({
        chatId: chatId
      }).then(function (_ref16) {
        var threads = _ref16.threads;

        if (!threads.length) {
          throw createError({
            message: "There is no thread in \"" + chatId + "\".",
            code: MISSING_CHAT_THREAD
          });
        }

        return api.updateThreadProperties({
          chatId: chatId,
          threadId: threads[0].id,
          properties: {
            rating: rating
          }
        });
      });
    },
    sendEvent: function (_sendEvent) {
      function sendEvent$$1(_x) {
        return _sendEvent.apply(this, arguments);
      }

      sendEvent$$1.toString = function () {
        return _sendEvent.toString();
      };

      return sendEvent$$1;
    }(function (params) {
      return sendRequestAction$$1(sendEvent(params));
    }),
    sendTicketForm: function sendTicketForm$$1(options) {
      return sendTicketForm(store, auth, options);
    },
    sendRichMessagePostback: function sendRichMessagePostback(_ref17) {
      var chatId = _ref17.chatId,
          threadId = _ref17.threadId,
          eventId = _ref17.eventId,
          postback = _ref17.postback;
      return sendRequestAction$$1(sendRequest(SEND_RICH_MESSAGE_POSTBACK, {
        chat_id: chatId,
        event_id: eventId,
        thread_id: threadId,
        postback: postback
      }));
    },
    setCustomerSessionFields: function setCustomerSessionFields(_ref18) {
      var sessionFields = _ref18.sessionFields;
      return sendRequestAction$$1(sendRequest(SET_CUSTOMER_SESSION_FIELDS, {
        session_fields: parseCustomerSessionFields(sessionFields)
      }));
    },
    setSneakPeek: function setSneakPeek(_ref19) {
      var chatId = _ref19.chatId,
          sneakPeekText = _ref19.sneakPeekText;
      var state = store.getState();

      if (!isChatActive(state, chatId) || !isConnected(state)) {
        return;
      }

      sendRequestAction$$1(sendRequest(SEND_SNEAK_PEEK, {
        chat_id: chatId,
        sneak_peek_text: sneakPeekText
      })).catch(noop);
    },
    startChat: function startChat(data) {
      if (data === void 0) {
        data = {};
      }

      log({
        env: env,
        licenseId: config.licenseId,
        eventName: 'chat_started'
      });
      return sendRequestAction$$1(sendRequest(START_CHAT, parseStartChatData(data)));
    },
    updateChatProperties: function updateChatProperties(_ref20) {
      var chatId = _ref20.chatId,
          properties = _ref20.properties;
      return sendRequestAction$$1(sendRequest(UPDATE_CHAT_PROPERTIES, {
        chat_id: chatId,
        properties: properties
      }));
    },
    updateCustomer: function updateCustomer(update) {
      return sendRequestAction$$1(sendRequest(UPDATE_CUSTOMER, parseCustomerUpdate(update)));
    },
    updateCustomerPage: function updateCustomerPage(page) {
      store.dispatch({
        type: UPDATE_CUSTOMER_PAGE,
        payload: pickOwn(['title', 'url'], page)
      });
    },
    updateEventProperties: function updateEventProperties(_ref21) {
      var chatId = _ref21.chatId,
          threadId = _ref21.threadId,
          eventId = _ref21.eventId,
          properties = _ref21.properties;
      return sendRequestAction$$1(sendRequest(UPDATE_EVENT_PROPERTIES, {
        chat_id: chatId,
        event_id: eventId,
        thread_id: threadId,
        properties: properties
      }));
    },
    updateThreadProperties: function updateThreadProperties(_ref22) {
      var chatId = _ref22.chatId,
          threadId = _ref22.threadId,
          properties = _ref22.properties;
      return sendRequestAction$$1(sendRequest(UPDATE_THREAD_PROPERTIES, {
        chat_id: chatId,
        thread_id: threadId,
        properties: properties
      }));
    },
    uploadFile: function uploadFile$$1(options) {
      return uploadFile({
        auth: auth,
        store: store
      }, options);
    }
  });

  if (autoConnect) {
    startConnection();
  } else {
    store.dispatch({
      type: CHECK_GOALS,
      payload: {
        sessionFields: typeof customerDataProvider === 'function' ? customerDataProvider().sessionFields : {}
      }
    });
  }

  return api;
};

export { init, debug, parseFile, parseFilledForm, parseMessage, parseRichMessage, parseSystemMessage, parseEvent$1 as parseEvent, parseGreeting };
