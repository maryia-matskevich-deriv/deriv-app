import { loggerRelationsMap } from './Logger.constants';
import { ILoggerConfig, TLoggerLevels, TLoggerApplicationType, ILoggerLogOptions, ILoggerLogParams, TLoggerHandler, ILoggerSubscriber, TLoggerOutputLevels, TReject } from './Logger.types';
export * from './Logger.types';
export * from './Logger.constants';
export declare class Logger {
    readonly relations: typeof loggerRelationsMap;
    applicationType: TLoggerApplicationType;
    level: TLoggerLevels;
    readonly subscribers: ILoggerSubscriber[];
    applicationCode: string | undefined;
    domain: string | undefined;
    deviceInfo: {
        [key: string]: any;
    } | undefined;
    constructor(config?: ILoggerConfig);
    updateLogLevel(level: TLoggerLevels): void;
    updateApplicationType(applicationType: TLoggerApplicationType): void;
    updateApplicationCode(applicationCode: string): void;
    updateDomain(domain: string): void;
    updateDeviceInfo(deviceInfo: {
        [key: string]: any;
    }): void;
    subscribe(level: TLoggerOutputLevels, handler: TLoggerHandler): void;
    log(params: ILoggerLogParams): Promise<void>;
    debug(text: string, options?: ILoggerLogOptions): Promise<void>;
    info(text: string, options?: ILoggerLogOptions): Promise<void>;
    warn(text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    error(text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    fatal(text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    errorAndThrow(text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    errorAndReject(cb: TReject, text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    fatalAndThrow(text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    fatalAndReject(cb: TReject, text: string, code?: string, options?: ILoggerLogOptions): Promise<void>;
    private logAndThrow;
    private logAndReject;
    private getMessage;
}
